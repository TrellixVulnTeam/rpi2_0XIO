<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="DBusGLib" version="1.0"/>
  <include name="Gio" version="2.0"/>
  <include name="NetworkManager" version="1.0"/>
  <package name="libnm-glib"/>
  <package name="libnm-glib-vpn"/>
  <namespace name="NMClient"
             version="1.0"
             shared-library="libnm-glib.so.4,libnm-util.so.2"
             c:identifier-prefixes="NM"
             c:symbol-prefixes="nm">
    <alias name="RemoteConnectionCommitFunc"
           c:type="NMRemoteConnectionCommitFunc">
      <type name="RemoteConnectionResultFunc"
            c:type="NMRemoteConnectionResultFunc"/>
    </alias>
    <alias name="RemoteConnectionDeleteFunc"
           c:type="NMRemoteConnectionDeleteFunc">
      <type name="RemoteConnectionResultFunc"
            c:type="NMRemoteConnectionResultFunc"/>
    </alias>
    <constant name="ACCESS_POINT_BSSID"
              value="bssid"
              c:type="NM_ACCESS_POINT_BSSID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_FLAGS"
              value="flags"
              c:type="NM_ACCESS_POINT_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_FREQUENCY"
              value="frequency"
              c:type="NM_ACCESS_POINT_FREQUENCY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_HW_ADDRESS"
              value="hw-address"
              c:type="NM_ACCESS_POINT_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_MAX_BITRATE"
              value="max-bitrate"
              c:type="NM_ACCESS_POINT_MAX_BITRATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_MODE"
              value="mode"
              c:type="NM_ACCESS_POINT_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_RSN_FLAGS"
              value="rsn-flags"
              c:type="NM_ACCESS_POINT_RSN_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_SSID"
              value="ssid"
              c:type="NM_ACCESS_POINT_SSID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_STRENGTH"
              value="strength"
              c:type="NM_ACCESS_POINT_STRENGTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_WPA_FLAGS"
              value="wpa-flags"
              c:type="NM_ACCESS_POINT_WPA_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_CONNECTION"
              value="connection"
              c:type="NM_ACTIVE_CONNECTION_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_DEFAULT"
              value="default"
              c:type="NM_ACTIVE_CONNECTION_DEFAULT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_DEFAULT6"
              value="default6"
              c:type="NM_ACTIVE_CONNECTION_DEFAULT6">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_DEVICES"
              value="devices"
              c:type="NM_ACTIVE_CONNECTION_DEVICES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_DHCP4_CONFIG"
              value="dhcp4-config"
              c:type="NM_ACTIVE_CONNECTION_DHCP4_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_DHCP6_CONFIG"
              value="dhcp6-config"
              c:type="NM_ACTIVE_CONNECTION_DHCP6_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_ID"
              value="id"
              c:type="NM_ACTIVE_CONNECTION_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_IP4_CONFIG"
              value="ip4-config"
              c:type="NM_ACTIVE_CONNECTION_IP4_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_IP6_CONFIG"
              value="ip6-config"
              c:type="NM_ACTIVE_CONNECTION_IP6_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_MASTER"
              value="master"
              c:type="NM_ACTIVE_CONNECTION_MASTER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_SPECIFIC_OBJECT"
              value="specific-object"
              c:type="NM_ACTIVE_CONNECTION_SPECIFIC_OBJECT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_STATE"
              value="state"
              c:type="NM_ACTIVE_CONNECTION_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_TYPE"
              value="type"
              c:type="NM_ACTIVE_CONNECTION_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_UUID"
              value="uuid"
              c:type="NM_ACTIVE_CONNECTION_UUID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_VPN"
              value="vpn"
              c:type="NM_ACTIVE_CONNECTION_VPN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="AccessPoint"
           c:symbol-prefix="access_point"
           c:type="NMAccessPoint"
           parent="Object"
           glib:type-name="NMAccessPoint"
           glib:get-type="nm_access_point_get_type"
           glib:type-struct="AccessPointClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_access_point_new">
        <doc xml:space="preserve">Creates a new #NMAccessPoint.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new access point</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the DBusobject path of the access point</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="connection_valid"
              c:identifier="nm_access_point_connection_valid">
        <doc xml:space="preserve">Validates a given connection against a given Wi-Fi access point to ensure that
the connection may be activated with that AP.  The connection must match the
@ap's SSID, (if given) BSSID, and other attributes like security settings,
channel, band, etc.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection may be activated with this Wi-Fi AP,
%FALSE if it cannot be.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">an #NMAccessPoint to validate @connection against</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">an #NMConnection to validate against @ap</doc>
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="filter_connections"
              c:identifier="nm_access_point_filter_connections">
        <doc xml:space="preserve">Filters a given list of connections for a given #NMAccessPoint object and
return connections which may be activated with the access point.  Any
returned connections will match the @ap's SSID and (if given) BSSID and
other attributes like security settings, channel, etc.

To obtain the list of connections that are compatible with this access point,
use nm_remote_settings_list_connections() and then filter the returned list
for a given #NMDevice using nm_device_filter_connections() and finally
filter that list with this function.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a
list of #NMConnection objects that could be activated with the given @ap.
The elements of the list are owned by their creator and should not be freed
by the caller, but the returned list itself is owned by the caller and should
be freed with g_slist_free() when it is no longer required.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="NetworkManager.Connection"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">an #NMAccessPoint to filter connections for</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
          <parameter name="connections" transfer-ownership="none">
            <doc xml:space="preserve">a list of
#NMConnection objects to filter</doc>
            <type name="GLib.SList" c:type="const GSList*">
              <type name="NetworkManager.Connection"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="get_bssid" c:identifier="nm_access_point_get_bssid">
        <doc xml:space="preserve">Gets the Basic Service Set ID (BSSID) of the Wi-Fi access point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the BSSID of the access point. This is an internal string and must
not be modified or freed.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="nm_access_point_get_flags">
        <doc xml:space="preserve">Gets the flags of the access point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the flags</doc>
          <type name="NetworkManager.80211ApFlags" c:type="NM80211ApFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_frequency"
              c:identifier="nm_access_point_get_frequency">
        <doc xml:space="preserve">Gets the frequency of the access point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the frequency</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_access_point_get_hw_address"
              deprecated="1"
              deprecated-version="0.9">
        <doc xml:space="preserve">Gets the hardware (MAC) address of the access point.</doc>
        <doc-deprecated xml:space="preserve">Use nm_access_point_get_bssid() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hardware address of the access point. This is the internal string used by the
access point and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max_bitrate"
              c:identifier="nm_access_point_get_max_bitrate">
        <doc xml:space="preserve">Gets the maximum bit rate of the access point in kbit/s.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the maximum bit rate (kbit/s)</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mode" c:identifier="nm_access_point_get_mode">
        <doc xml:space="preserve">Gets the mode of the access point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the mode</doc>
          <type name="NetworkManager.80211Mode" c:type="NM80211Mode"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_rsn_flags"
              c:identifier="nm_access_point_get_rsn_flags">
        <doc xml:space="preserve">Gets the RSN (Robust Secure Network, ie WPA version 2) flags of the access
point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the RSN flags</doc>
          <type name="NetworkManager.80211ApSecurityFlags"
                c:type="NM80211ApSecurityFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ssid" c:identifier="nm_access_point_get_ssid">
        <doc xml:space="preserve">Gets the SSID of the access point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GByteArray containing the SSID. This is the internal copy used by the
access point, and must not be modified.</doc>
          <array name="GLib.ByteArray" c:type="const GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_strength" c:identifier="nm_access_point_get_strength">
        <doc xml:space="preserve">Gets the current signal strength of the access point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the signal strength</doc>
          <type name="guint8" c:type="guint8"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_wpa_flags"
              c:identifier="nm_access_point_get_wpa_flags">
        <doc xml:space="preserve">Gets the WPA (version 1) flags of the access point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the WPA flags</doc>
          <type name="NetworkManager.80211ApSecurityFlags"
                c:type="NM80211ApSecurityFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="bssid" transfer-ownership="none">
        <doc xml:space="preserve">The BSSID of the access point.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="flags" transfer-ownership="none">
        <doc xml:space="preserve">The flags of the access point.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="frequency" transfer-ownership="none">
        <doc xml:space="preserve">The frequency of the access point.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:space="preserve">The hardware address of the access point.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="max-bitrate" transfer-ownership="none">
        <doc xml:space="preserve">The maximum bit rate of the access point in kbit/s.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="mode" transfer-ownership="none">
        <doc xml:space="preserve">The mode of the access point; either "infrastructure" (a central
coordinator of the wireless network allowing clients to connect) or
"ad-hoc" (a network with no central controller).</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="rsn-flags" transfer-ownership="none">
        <doc xml:space="preserve">The RSN flags of the access point.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="ssid" transfer-ownership="none">
        <doc xml:space="preserve">The SSID of the access point.</doc>
        <type name="Ssid"/>
      </property>
      <property name="strength" transfer-ownership="none">
        <doc xml:space="preserve">The current signal strength of the access point.</doc>
        <type name="guint8" c:type="guint8"/>
      </property>
      <property name="wpa-flags" transfer-ownership="none">
        <doc xml:space="preserve">The WPA flags of the access point.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Object" c:type="NMObject"/>
      </field>
    </class>
    <record name="AccessPointClass"
            c:type="NMAccessPointClass"
            glib:is-gtype-struct-for="AccessPoint">
      <field name="parent">
        <type name="ObjectClass" c:type="NMObjectClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <class name="ActiveConnection"
           c:symbol-prefix="active_connection"
           c:type="NMActiveConnection"
           parent="Object"
           glib:type-name="NMActiveConnection"
           glib:get-type="nm_active_connection_get_type"
           glib:type-struct="ActiveConnectionClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_active_connection_new">
        <doc xml:space="preserve">Creates a new #NMActiveConnection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new active connection</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_connection"
              c:identifier="nm_active_connection_get_connection">
        <doc xml:space="preserve">Gets the #NMConnection's DBus object path.  This is often used with
nm_remote_settings_get_connection_by_path() to retrieve the
#NMRemoteConnection object that describes the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the object path of the #NMConnection which this #NMActiveConnection
is an active instance of.  This is the internal string used by the
connection, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_connection_type"
              c:identifier="nm_active_connection_get_connection_type"
              version="0.9.10">
        <doc xml:space="preserve">Gets the #NMConnection's type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type of the #NMConnection that backs the #NMActiveConnection.
This is the internal string used by the connection, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_default"
              c:identifier="nm_active_connection_get_default">
        <doc xml:space="preserve">Whether the active connection is the default IPv4 one (that is, is used for
the default IPv4 route and DNS information).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the active connection is the default IPv4 connection</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_default6"
              c:identifier="nm_active_connection_get_default6">
        <doc xml:space="preserve">Whether the active connection is the default IPv6 one (that is, is used for
the default IPv6 route and DNS information).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the active connection is the default IPv6 connection</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_devices"
              c:identifier="nm_active_connection_get_devices">
        <doc xml:space="preserve">Gets the #NMDevices used for the active connections.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GPtrArray containing #NMDevices.
This is the internal copy used by the connection, and must not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="Device"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dhcp4_config"
              c:identifier="nm_active_connection_get_dhcp4_config"
              version="0.9.10">
        <doc xml:space="preserve">Gets the current #NMDHCP4Config (if any) associated with the
#NMActiveConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMDHCP4Config, or %NULL if the
  connection does not use DHCP, or is not in the
  %NM_ACTIVE_CONNECTION_STATE_ACTIVATED state.</doc>
          <type name="DHCP4Config" c:type="NMDHCP4Config*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">an #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dhcp6_config"
              c:identifier="nm_active_connection_get_dhcp6_config"
              version="0.9.10">
        <doc xml:space="preserve">Gets the current #NMDHCP6Config (if any) associated with the
#NMActiveConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMDHCP6Config, or %NULL if the
  connection does not use DHCPv6, or is not in the
  %NM_ACTIVE_CONNECTION_STATE_ACTIVATED state.</doc>
          <type name="DHCP6Config" c:type="NMDHCP6Config*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">an #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_id"
              c:identifier="nm_active_connection_get_id"
              version="0.9.10">
        <doc xml:space="preserve">Gets the #NMConnection's ID.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the ID of the #NMConnection that backs the #NMActiveConnection.
This is the internal string used by the connection, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ip4_config"
              c:identifier="nm_active_connection_get_ip4_config"
              version="0.9.10">
        <doc xml:space="preserve">Gets the current #NMIP4Config associated with the #NMActiveConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMIP4Config, or %NULL if the
  connection is not in the %NM_ACTIVE_CONNECTION_STATE_ACTIVATED
  state.</doc>
          <type name="IP4Config" c:type="NMIP4Config*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">an #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ip6_config"
              c:identifier="nm_active_connection_get_ip6_config"
              version="0.9.10">
        <doc xml:space="preserve">Gets the current #NMIP6Config associated with the #NMActiveConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMIP6Config, or %NULL if the
  connection is not in the %NM_ACTIVE_CONNECTION_STATE_ACTIVATED
  state.</doc>
          <type name="IP6Config" c:type="NMIP6Config*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">an #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_master" c:identifier="nm_active_connection_get_master">
        <doc xml:space="preserve">Gets the path to the master #NMDevice of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the path of the master #NMDevice of the #NMActiveConnection.
This is the internal string used by the connection, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_specific_object"
              c:identifier="nm_active_connection_get_specific_object">
        <doc xml:space="preserve">Gets the "specific object" used at the activation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the specific object's DBus path. This is the internal string used by the
connection, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_state" c:identifier="nm_active_connection_get_state">
        <doc xml:space="preserve">Gets the active connection's state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the state</doc>
          <type name="NetworkManager.ActiveConnectionState"
                c:type="NMActiveConnectionState"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uuid" c:identifier="nm_active_connection_get_uuid">
        <doc xml:space="preserve">Gets the #NMConnection's UUID.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the UUID of the #NMConnection that backs the #NMActiveConnection.
This is the internal string used by the connection, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vpn"
              c:identifier="nm_active_connection_get_vpn"
              version="0.9.10">
        <doc xml:space="preserve">Whether the active connection is a VPN connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the active connection is a VPN connection</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="connection" transfer-ownership="none">
        <doc xml:space="preserve">The connection's path of the active connection.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="default" transfer-ownership="none">
        <doc xml:space="preserve">Whether the active connection is the default IPv4 one.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="default6" transfer-ownership="none">
        <doc xml:space="preserve">Whether the active connection is the default IPv6 one.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="devices" transfer-ownership="none">
        <type name="ObjectArray"/>
      </property>
      <property name="dhcp4-config" version="0.9.10" transfer-ownership="none">
        <doc xml:space="preserve">The #NMDHCP4Config of the connection.</doc>
        <type name="DHCP4Config"/>
      </property>
      <property name="dhcp6-config" version="0.9.10" transfer-ownership="none">
        <doc xml:space="preserve">The #NMDHCP6Config of the connection.</doc>
        <type name="DHCP6Config"/>
      </property>
      <property name="id" version="0.9.10" transfer-ownership="none">
        <doc xml:space="preserve">The active connection's ID</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="ip4-config" version="0.9.10" transfer-ownership="none">
        <doc xml:space="preserve">The #NMIP4Config of the connection.</doc>
        <type name="IP4Config"/>
      </property>
      <property name="ip6-config" version="0.9.10" transfer-ownership="none">
        <doc xml:space="preserve">The #NMIP6Config of the connection.</doc>
        <type name="IP6Config"/>
      </property>
      <property name="master" transfer-ownership="none">
        <doc xml:space="preserve">The path of the master device if one exists.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="specific-object" transfer-ownership="none">
        <doc xml:space="preserve">The specific object's path of the active connection.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="state" transfer-ownership="none">
        <doc xml:space="preserve">The state of the active connection.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="type" version="0.9.10" transfer-ownership="none">
        <doc xml:space="preserve">The active connection's type</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="uuid" transfer-ownership="none">
        <doc xml:space="preserve">The active connection's UUID</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="vpn" version="0.9.10" transfer-ownership="none">
        <doc xml:space="preserve">Whether the active connection is a VPN connection.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="Object" c:type="NMObject"/>
      </field>
    </class>
    <record name="ActiveConnectionClass"
            c:type="NMActiveConnectionClass"
            glib:is-gtype-struct-for="ActiveConnection">
      <field name="parent">
        <type name="ObjectClass" c:type="NMObjectClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <constant name="CLIENT_ACTIVATING_CONNECTION"
              value="activating-connection"
              c:type="NM_CLIENT_ACTIVATING_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_ACTIVE_CONNECTIONS"
              value="active-connections"
              c:type="NM_CLIENT_ACTIVE_CONNECTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_CONNECTIVITY"
              value="connectivity"
              c:type="NM_CLIENT_CONNECTIVITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_DEVICES" value="devices" c:type="NM_CLIENT_DEVICES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_MANAGER_RUNNING"
              value="manager-running"
              c:type="NM_CLIENT_MANAGER_RUNNING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_NETWORKING_ENABLED"
              value="networking-enabled"
              c:type="NM_CLIENT_NETWORKING_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_PRIMARY_CONNECTION"
              value="primary-connection"
              c:type="NM_CLIENT_PRIMARY_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_STARTUP" value="startup" c:type="NM_CLIENT_STARTUP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_STATE" value="state" c:type="NM_CLIENT_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_VERSION" value="version" c:type="NM_CLIENT_VERSION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_WIMAX_ENABLED"
              value="wimax-enabled"
              c:type="NM_CLIENT_WIMAX_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_WIMAX_HARDWARE_ENABLED"
              value="wimax-hardware-enabled"
              c:type="NM_CLIENT_WIMAX_HARDWARE_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_WIRELESS_ENABLED"
              value="wireless-enabled"
              c:type="NM_CLIENT_WIRELESS_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_WIRELESS_HARDWARE_ENABLED"
              value="wireless-hardware-enabled"
              c:type="NM_CLIENT_WIRELESS_HARDWARE_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_WWAN_ENABLED"
              value="wwan-enabled"
              c:type="NM_CLIENT_WWAN_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_WWAN_HARDWARE_ENABLED"
              value="wwan-hardware-enabled"
              c:type="NM_CLIENT_WWAN_HARDWARE_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="Client"
           c:symbol-prefix="client"
           c:type="NMClient"
           parent="Object"
           glib:type-name="NMClient"
           glib:get-type="nm_client_get_type"
           glib:type-struct="ClientClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_client_new">
        <doc xml:space="preserve">Creates a new #NMClient.

Note that this will do blocking D-Bus calls to initialize the
client. You can use nm_client_new_async() if you want to avoid
that.

NOTE: #NMClient provides information about devices and a mechanism to
control them.  To access and modify network configuration data, use the
#NMRemoteSettings object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #NMClient or NULL on an error</doc>
          <type name="Client" c:type="NMClient*"/>
        </return-value>
      </constructor>
      <constructor name="new_finish"
                   c:identifier="nm_client_new_finish"
                   throws="1">
        <doc xml:space="preserve">Gets the result of an nm_client_new_async() call.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #NMClient, or %NULL on error</doc>
          <type name="Client" c:type="NMClient*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="new_async" c:identifier="nm_client_new_async">
        <doc xml:space="preserve">Creates a new #NMClient and begins asynchronously initializing it.
@callback will be called when it is done; use
nm_client_new_finish() to get the result. Note that on an error,
the callback can be invoked with two first parameters as NULL.

NOTE: #NMClient provides information about devices and a mechanism to
control them.  To access and modify network configuration data, use the
#NMRemoteSettings object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">callback to call when the client is created</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="device_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="device" transfer-ownership="none">
            <type name="Device" c:type="NMDevice*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="device_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="device" transfer-ownership="none">
            <type name="Device" c:type="NMDevice*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="permission_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="permission" transfer-ownership="none">
            <type name="ClientPermission" c:type="NMClientPermission"/>
          </parameter>
          <parameter name="result" transfer-ownership="none">
            <type name="ClientPermissionResult"
                  c:type="NMClientPermissionResult"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="activate_connection"
              c:identifier="nm_client_activate_connection">
        <doc xml:space="preserve">Starts a connection to a particular network using the configuration settings
from @connection and the network device @device.  Certain connection types
also take a "specific object" which is the object path of a connection-
specific object, like an #NMAccessPoint for Wi-Fi connections, or an
#NMWimaxNsp for WiMAX connections, to which you wish to connect.  If the
specific object is not given, NetworkManager can, in some cases, automatically
determine which network to connect to given the settings in @connection.

If @connection is not given for a device-based activation, NetworkManager
picks the best available connection for the device and activates it.

Note that the callback is invoked when NetworkManager has started activating
the new connection, not when it finishes. You can used the returned
#NMActiveConnection object (in particular, #NMActiveConnection:state) to
track the activation to its completion.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="connection"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">an #NMConnection</doc>
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="device"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </parameter>
          <parameter name="specific_object"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the object path of a connection-type-specific
  object this activation should use. This parameter is currently ignored for
  wired and mobile broadband connections, and the value of %NULL should be used
  (ie, no specific object).  For Wi-Fi or WiMAX connections, pass the object
  path of a #NMAccessPoint or #NMWimaxNsp owned by @device, which you can
  get using nm_object_get_path(), and which will be used to complete the
  details of the newly added connection.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">the function to call when the call is done</doc>
            <type name="ClientActivateFn" c:type="NMClientActivateFn"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">user data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_and_activate_connection"
              c:identifier="nm_client_add_and_activate_connection">
        <doc xml:space="preserve">Adds a new connection using the given details (if any) as a template,
automatically filling in missing settings with the capabilities of the
given device and specific object.  The new connection is then activated.
Cannot be used for VPN connections at this time.

Note that the callback is invoked when NetworkManager has started activating
the new connection, not when it finishes. You can used the returned
#NMActiveConnection object (in particular, #NMActiveConnection:state) to
track the activation to its completion.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="partial"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">an #NMConnection to add; the connection may be
  partially filled (or even %NULL) and will be completed by NetworkManager
  using the given @device and @specific_object before being added</doc>
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">the #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </parameter>
          <parameter name="specific_object"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the object path of a connection-type-specific
  object this activation should use. This parameter is currently ignored for
  wired and mobile broadband connections, and the value of %NULL should be used
  (ie, no specific object).  For Wi-Fi or WiMAX connections, pass the object
  path of a #NMAccessPoint or #NMWimaxNsp owned by @device, which you can
  get using nm_object_get_path(), and which will be used to complete the
  details of the newly added connection.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">the function to call when the call is done</doc>
            <type name="ClientAddActivateFn" c:type="NMClientAddActivateFn"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">user data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="check_connectivity"
              c:identifier="nm_client_check_connectivity"
              version="0.9.8.6"
              throws="1">
        <doc xml:space="preserve">Updates the network connectivity state and returns the (new)
current state. Contrast nm_client_get_connectivity(), which returns
the most recent known state without re-checking.

This is a blocking call; use nm_client_check_connectivity_async()
if you do not want to block.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the (new) current connectivity state</doc>
          <type name="NetworkManager.ConnectivityState"
                c:type="NMConnectivityState"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">an #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="check_connectivity_async"
              c:identifier="nm_client_check_connectivity_async"
              version="0.9.8.6">
        <doc xml:space="preserve">Asynchronously updates the network connectivity state and invokes
@callback when complete. Contrast nm_client_get_connectivity(),
which (immediately) returns the most recent known state without
re-checking, and nm_client_check_connectivity(), which blocks.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">an #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">callback to call with the result</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data for @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="check_connectivity_finish"
              c:identifier="nm_client_check_connectivity_finish"
              version="0.9.8.6"
              throws="1">
        <doc xml:space="preserve">Retrieves the result of an nm_client_check_connectivity_async()
call.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the (new) current connectivity state</doc>
          <type name="NetworkManager.ConnectivityState"
                c:type="NMConnectivityState"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">an #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="deactivate_connection"
              c:identifier="nm_client_deactivate_connection">
        <doc xml:space="preserve">Deactivates an active #NMActiveConnection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="active" transfer-ownership="none">
            <doc xml:space="preserve">the #NMActiveConnection to deactivate</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_activating_connection"
              c:identifier="nm_client_get_activating_connection"
              version="0.9.8.6">
        <doc xml:space="preserve">Gets the #NMActiveConnection corresponding to a
currently-activating connection that is expected to become the new
#NMClient:primary-connection upon successful activation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the appropriate #NMActiveConnection, if
any.</doc>
          <type name="ActiveConnection" c:type="NMActiveConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">an #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_active_connections"
              c:identifier="nm_client_get_active_connections">
        <doc xml:space="preserve">Gets the active connections.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GPtrArray
 containing all the active #NMActiveConnections.
The returned array is owned by the client and should not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="ActiveConnection"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_connectivity"
              c:identifier="nm_client_get_connectivity"
              version="0.9.8.6">
        <doc xml:space="preserve">Gets the current network connectivity state. Contrast
nm_client_check_connectivity() and
nm_client_check_connectivity_async(), which re-check the
connectivity state first before returning any information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current connectivity state</doc>
          <type name="NetworkManager.ConnectivityState"
                c:type="NMConnectivityState"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">an #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_device_by_iface"
              c:identifier="nm_client_get_device_by_iface">
        <doc xml:space="preserve">Gets a #NMDevice from a #NMClient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMDevice for the given @iface or %NULL if none is found.</doc>
          <type name="Device" c:type="NMDevice*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="iface" transfer-ownership="none">
            <doc xml:space="preserve">the interface name to search for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_device_by_path"
              c:identifier="nm_client_get_device_by_path">
        <doc xml:space="preserve">Gets a #NMDevice from a #NMClient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMDevice for the given @object_path or %NULL if none is found.</doc>
          <type name="Device" c:type="NMDevice*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">the object path to search for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_devices" c:identifier="nm_client_get_devices">
        <doc xml:space="preserve">Gets all the known network devices.  Use nm_device_get_type() or the
&lt;literal&gt;NM_IS_DEVICE_XXXX&lt;/literal&gt; functions to determine what kind of
device member of the returned array is, and then you may use device-specific
methods such as nm_device_ethernet_get_hw_address().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GPtrArray
containing all the #NMDevices.  The returned array is owned by the
#NMClient object and should not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="Device"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_logging"
              c:identifier="nm_client_get_logging"
              version="0.9.8"
              throws="1">
        <doc xml:space="preserve">Gets NetworkManager current logging level and domains.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="level"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">return location for logging level string</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
          <parameter name="domains"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">return location for log domains string. The string is
  a list of domains separated by ","</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_manager_running"
              c:identifier="nm_client_get_manager_running">
        <doc xml:space="preserve">Determines whether the daemon is running.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the daemon is running</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_permission_result"
              c:identifier="nm_client_get_permission_result">
        <doc xml:space="preserve">Requests the result of a specific permission, which indicates whether the
client can or cannot perform the action the permission represents</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the permission's result, one of #NMClientPermissionResult</doc>
          <type name="ClientPermissionResult"
                c:type="NMClientPermissionResult"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="permission" transfer-ownership="none">
            <doc xml:space="preserve">the permission for which to return the result, one of #NMClientPermission</doc>
            <type name="ClientPermission" c:type="NMClientPermission"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_primary_connection"
              c:identifier="nm_client_get_primary_connection"
              version="0.9.8.6">
        <doc xml:space="preserve">Gets the #NMActiveConnection corresponding to the primary active
network device.

In particular, when there is no VPN active, or the VPN does not
have the default route, this returns the active connection that has
the default route. If there is a VPN active with the default route,
then this function returns the active connection that contains the
route to the VPN endpoint.

If there is no default route, or the default route is over a
non-NetworkManager-recognized device, this will return %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the appropriate #NMActiveConnection, if
any</doc>
          <type name="ActiveConnection" c:type="NMActiveConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">an #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_startup"
              c:identifier="nm_client_get_startup"
              version="0.9.10">
        <doc xml:space="preserve">Tests whether the daemon is still in the process of activating
connections at startup.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the daemon is still starting up</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_state" c:identifier="nm_client_get_state">
        <doc xml:space="preserve">Gets the current daemon state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current %NMState</doc>
          <type name="NetworkManager.State" c:type="NMState"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_version" c:identifier="nm_client_get_version">
        <doc xml:space="preserve">Gets NetworkManager version.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">string with the version</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="networking_get_enabled"
              c:identifier="nm_client_networking_get_enabled">
        <doc xml:space="preserve">Whether networking is enabled or disabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if networking is enabled, %FALSE if networking is disabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="networking_set_enabled"
              c:identifier="nm_client_networking_set_enabled">
        <doc xml:space="preserve">Enables or disables networking.  When networking is disabled, all controlled
interfaces are disconnected and deactivated.  When networking is enabled,
all controlled interfaces are available for activation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to set networking enabled, %FALSE to set networking disabled</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_logging"
              c:identifier="nm_client_set_logging"
              version="0.9.8"
              throws="1">
        <doc xml:space="preserve">Sets NetworkManager logging level and/or domains.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="level"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">logging level to set (%NULL or an empty string for no change)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="domains"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">logging domains to set. The string should be a list of log
  domains separated by ",". (%NULL or an empty string for no change)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="sleep" c:identifier="nm_client_sleep">
        <doc xml:space="preserve">Deprecated; use nm_client_networking_set_enabled() instead.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="sleep_" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to put the daemon to sleep</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="wimax_get_enabled"
              c:identifier="nm_client_wimax_get_enabled">
        <doc xml:space="preserve">Determines whether WiMAX is enabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if WiMAX is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wimax_hardware_get_enabled"
              c:identifier="nm_client_wimax_hardware_get_enabled">
        <doc xml:space="preserve">Determines whether the WiMAX hardware is enabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the WiMAX hardware is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wimax_set_enabled"
              c:identifier="nm_client_wimax_set_enabled">
        <doc xml:space="preserve">Enables or disables WiMAX devices.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to enable WiMAX</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="wireless_get_enabled"
              c:identifier="nm_client_wireless_get_enabled">
        <doc xml:space="preserve">Determines whether the wireless is enabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if wireless is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wireless_hardware_get_enabled"
              c:identifier="nm_client_wireless_hardware_get_enabled">
        <doc xml:space="preserve">Determines whether the wireless hardware is enabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the wireless hardware is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wireless_set_enabled"
              c:identifier="nm_client_wireless_set_enabled">
        <doc xml:space="preserve">Enables or disables wireless devices.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to enable wireless</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="wwan_get_enabled"
              c:identifier="nm_client_wwan_get_enabled">
        <doc xml:space="preserve">Determines whether WWAN is enabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if WWAN is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wwan_hardware_get_enabled"
              c:identifier="nm_client_wwan_hardware_get_enabled">
        <doc xml:space="preserve">Determines whether the WWAN hardware is enabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the WWAN hardware is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wwan_set_enabled"
              c:identifier="nm_client_wwan_set_enabled">
        <doc xml:space="preserve">Enables or disables WWAN devices.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:space="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to enable WWAN</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="activating-connection"
                version="0.9.8.6"
                transfer-ownership="none">
        <doc xml:space="preserve">The #NMActiveConnection of the activating connection that is
likely to become the new #NMClient:primary-connection.</doc>
        <type name="ActiveConnection"/>
      </property>
      <property name="active-connections" transfer-ownership="none">
        <doc xml:space="preserve">The active connections.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="connectivity"
                version="0.9.8.6"
                transfer-ownership="none">
        <doc xml:space="preserve">The network connectivity state.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="devices" version="0.9.10" transfer-ownership="none">
        <doc xml:space="preserve">List of known network devices.</doc>
        <type name="ObjectArray"/>
      </property>
      <property name="manager-running" transfer-ownership="none">
        <doc xml:space="preserve">Whether the daemon is running.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="networking-enabled"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Whether networking is enabled.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="primary-connection"
                version="0.9.8.6"
                transfer-ownership="none">
        <doc xml:space="preserve">The #NMActiveConnection of the device with the default route;
see nm_client_get_primary_connection() for more details.</doc>
        <type name="ActiveConnection"/>
      </property>
      <property name="startup" version="0.9.10" transfer-ownership="none">
        <doc xml:space="preserve">Whether the daemon is still starting up.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="state" transfer-ownership="none">
        <doc xml:space="preserve">The current daemon state.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="version" transfer-ownership="none">
        <doc xml:space="preserve">The NetworkManager version.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="wimax-enabled" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether WiMAX functionality is enabled.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="wimax-hardware-enabled" transfer-ownership="none">
        <doc xml:space="preserve">Whether the WiMAX hardware is enabled.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="wireless-enabled" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether wireless is enabled.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="wireless-hardware-enabled" transfer-ownership="none">
        <doc xml:space="preserve">Whether the wireless hardware is enabled.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="wwan-enabled" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether WWAN functionality is enabled.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="wwan-hardware-enabled" transfer-ownership="none">
        <doc xml:space="preserve">Whether the WWAN hardware is enabled.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="Object" c:type="NMObject"/>
      </field>
      <glib:signal name="device-added" when="first">
        <doc xml:space="preserve">Notifies that a #NMDevice is added.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">the new device</doc>
            <type name="Device"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="device-removed" when="first">
        <doc xml:space="preserve">Notifies that a #NMDevice is removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">the removed device</doc>
            <type name="Device"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="permission-changed" when="first">
        <doc xml:space="preserve">Notifies that a permission has changed</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="permission" transfer-ownership="none">
            <doc xml:space="preserve">a permission from #NMClientPermission</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the permission's result, one of #NMClientPermissionResult</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <callback name="ClientActivateFn" c:type="NMClientActivateFn">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="client" transfer-ownership="none">
          <type name="Client" c:type="NMClient*"/>
        </parameter>
        <parameter name="active_connection" transfer-ownership="none">
          <type name="ActiveConnection" c:type="NMActiveConnection*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ClientAddActivateFn" c:type="NMClientAddActivateFn">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="client" transfer-ownership="none">
          <type name="Client" c:type="NMClient*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <type name="ActiveConnection" c:type="NMActiveConnection*"/>
        </parameter>
        <parameter name="new_connection_path" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="4">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ClientClass"
            c:type="NMClientClass"
            glib:is-gtype-struct-for="Client">
      <field name="parent">
        <type name="ObjectClass" c:type="NMObjectClass"/>
      </field>
      <field name="device_added">
        <callback name="device_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="client" transfer-ownership="none">
              <type name="Client" c:type="NMClient*"/>
            </parameter>
            <parameter name="device" transfer-ownership="none">
              <type name="Device" c:type="NMDevice*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="device_removed">
        <callback name="device_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="client" transfer-ownership="none">
              <type name="Client" c:type="NMClient*"/>
            </parameter>
            <parameter name="device" transfer-ownership="none">
              <type name="Device" c:type="NMDevice*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="permission_changed">
        <callback name="permission_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="client" transfer-ownership="none">
              <type name="Client" c:type="NMClient*"/>
            </parameter>
            <parameter name="permission" transfer-ownership="none">
              <type name="ClientPermission" c:type="NMClientPermission"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <type name="ClientPermissionResult"
                    c:type="NMClientPermissionResult"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="ClientError"
                 glib:type-name="NMClientError"
                 glib:get-type="nm_client_error_get_type"
                 c:type="NMClientError"
                 glib:error-domain="nm-client-error-quark">
      <doc xml:space="preserve">Describes errors that may result from operations involving a #NMClient.</doc>
      <member name="UnknownError"
              value="0"
              c:identifier="NM_CLIENT_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="ManagerNotRunning"
              value="1"
              c:identifier="NM_CLIENT_ERROR_MANAGER_NOT_RUNNING"
              glib:nick="ManagerNotRunning">
        <doc xml:space="preserve">an operation that requires NetworkManager
  failed because NetworkManager is not running</doc>
      </member>
      <function name="quark"
                c:identifier="nm_client_error_quark"
                version="0.9.10">
        <doc xml:space="preserve">Registers an error quark for #NMClient if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMClient errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <enumeration name="ClientPermission"
                 glib:type-name="NMClientPermission"
                 glib:get-type="nm_client_permission_get_type"
                 c:type="NMClientPermission">
      <doc xml:space="preserve">#NMClientPermission values indicate various permissions that NetworkManager
clients can obtain to perform certain tasks on behalf of the current user.</doc>
      <member name="none"
              value="0"
              c:identifier="NM_CLIENT_PERMISSION_NONE"
              glib:nick="none">
        <doc xml:space="preserve">unknown or no permission</doc>
      </member>
      <member name="enable_disable_network"
              value="1"
              c:identifier="NM_CLIENT_PERMISSION_ENABLE_DISABLE_NETWORK"
              glib:nick="enable-disable-network">
        <doc xml:space="preserve">controls whether networking
 can be globally enabled or disabled</doc>
      </member>
      <member name="enable_disable_wifi"
              value="2"
              c:identifier="NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIFI"
              glib:nick="enable-disable-wifi">
        <doc xml:space="preserve">controls whether Wi-Fi can be
 globally enabled or disabled</doc>
      </member>
      <member name="enable_disable_wwan"
              value="3"
              c:identifier="NM_CLIENT_PERMISSION_ENABLE_DISABLE_WWAN"
              glib:nick="enable-disable-wwan">
        <doc xml:space="preserve">controls whether WWAN (3G) can be
 globally enabled or disabled</doc>
      </member>
      <member name="enable_disable_wimax"
              value="4"
              c:identifier="NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIMAX"
              glib:nick="enable-disable-wimax">
        <doc xml:space="preserve">controls whether WiMAX can be
 globally enabled or disabled</doc>
      </member>
      <member name="sleep_wake"
              value="5"
              c:identifier="NM_CLIENT_PERMISSION_SLEEP_WAKE"
              glib:nick="sleep-wake">
        <doc xml:space="preserve">controls whether the client can ask
 NetworkManager to sleep and wake</doc>
      </member>
      <member name="network_control"
              value="6"
              c:identifier="NM_CLIENT_PERMISSION_NETWORK_CONTROL"
              glib:nick="network-control">
        <doc xml:space="preserve">controls whether networking connections
 can be started, stopped, and changed</doc>
      </member>
      <member name="wifi_share_protected"
              value="7"
              c:identifier="NM_CLIENT_PERMISSION_WIFI_SHARE_PROTECTED"
              glib:nick="wifi-share-protected">
        <doc xml:space="preserve">controls whether a password
 protected Wi-Fi hotspot can be created</doc>
      </member>
      <member name="wifi_share_open"
              value="8"
              c:identifier="NM_CLIENT_PERMISSION_WIFI_SHARE_OPEN"
              glib:nick="wifi-share-open">
        <doc xml:space="preserve">controls whether an open Wi-Fi hotspot
 can be created</doc>
      </member>
      <member name="settings_modify_system"
              value="9"
              c:identifier="NM_CLIENT_PERMISSION_SETTINGS_MODIFY_SYSTEM"
              glib:nick="settings-modify-system">
        <doc xml:space="preserve">controls whether connections
 that are available to all users can be modified</doc>
      </member>
      <member name="settings_modify_own"
              value="10"
              c:identifier="NM_CLIENT_PERMISSION_SETTINGS_MODIFY_OWN"
              glib:nick="settings-modify-own">
        <doc xml:space="preserve">controls whether connections
 owned by the current user can be modified</doc>
      </member>
      <member name="settings_modify_hostname"
              value="11"
              c:identifier="NM_CLIENT_PERMISSION_SETTINGS_MODIFY_HOSTNAME"
              glib:nick="settings-modify-hostname">
        <doc xml:space="preserve">controls whether the
 persistent hostname can be changed</doc>
      </member>
      <member name="last"
              value="11"
              c:identifier="NM_CLIENT_PERMISSION_LAST"
              glib:nick="last">
        <doc xml:space="preserve">a reserved boundary value</doc>
      </member>
    </enumeration>
    <enumeration name="ClientPermissionResult"
                 glib:type-name="NMClientPermissionResult"
                 glib:get-type="nm_client_permission_result_get_type"
                 c:type="NMClientPermissionResult">
      <doc xml:space="preserve">#NMClientPermissionResult values indicate what authorizations and permissions
the user requires to obtain a given #NMClientPermission</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_CLIENT_PERMISSION_RESULT_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">unknown or no authorization</doc>
      </member>
      <member name="yes"
              value="1"
              c:identifier="NM_CLIENT_PERMISSION_RESULT_YES"
              glib:nick="yes">
        <doc xml:space="preserve">the permission is available</doc>
      </member>
      <member name="auth"
              value="2"
              c:identifier="NM_CLIENT_PERMISSION_RESULT_AUTH"
              glib:nick="auth">
        <doc xml:space="preserve">authorization is necessary before the
 permission is available</doc>
      </member>
      <member name="no"
              value="3"
              c:identifier="NM_CLIENT_PERMISSION_RESULT_NO"
              glib:nick="no">
        <doc xml:space="preserve">permission to perform the operation is
 denied by system policy</doc>
      </member>
    </enumeration>
    <constant name="DEVICE_ACTIVE_CONNECTION"
              value="active-connection"
              c:type="NM_DEVICE_ACTIVE_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_ADSL_CARRIER"
              value="carrier"
              c:type="NM_DEVICE_ADSL_CARRIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_AUTOCONNECT"
              value="autoconnect"
              c:type="NM_DEVICE_AUTOCONNECT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_AVAILABLE_CONNECTIONS"
              value="available-connections"
              c:type="NM_DEVICE_AVAILABLE_CONNECTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BOND_CARRIER"
              value="carrier"
              c:type="NM_DEVICE_BOND_CARRIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BOND_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_BOND_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BOND_SLAVES"
              value="slaves"
              c:type="NM_DEVICE_BOND_SLAVES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BRIDGE_CARRIER"
              value="carrier"
              c:type="NM_DEVICE_BRIDGE_CARRIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BRIDGE_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_BRIDGE_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BRIDGE_SLAVES"
              value="slaves"
              c:type="NM_DEVICE_BRIDGE_SLAVES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BT_CAPABILITIES"
              value="bt-capabilities"
              c:type="NM_DEVICE_BT_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BT_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_BT_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BT_NAME" value="name" c:type="NM_DEVICE_BT_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_CAPABILITIES"
              value="capabilities"
              c:type="NM_DEVICE_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_DEVICE_TYPE"
              value="device-type"
              c:type="NM_DEVICE_DEVICE_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_DHCP4_CONFIG"
              value="dhcp4-config"
              c:type="NM_DEVICE_DHCP4_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_DHCP6_CONFIG"
              value="dhcp6-config"
              c:type="NM_DEVICE_DHCP6_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_DRIVER" value="driver" c:type="NM_DEVICE_DRIVER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_DRIVER_VERSION"
              value="driver-version"
              c:type="NM_DEVICE_DRIVER_VERSION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_ETHERNET_CARRIER"
              value="carrier"
              c:type="NM_DEVICE_ETHERNET_CARRIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_ETHERNET_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_ETHERNET_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_ETHERNET_PERMANENT_HW_ADDRESS"
              value="perm-hw-address"
              c:type="NM_DEVICE_ETHERNET_PERMANENT_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_ETHERNET_SPEED"
              value="speed"
              c:type="NM_DEVICE_ETHERNET_SPEED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_FIRMWARE_MISSING"
              value="firmware-missing"
              c:type="NM_DEVICE_FIRMWARE_MISSING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_FIRMWARE_VERSION"
              value="firmware-version"
              c:type="NM_DEVICE_FIRMWARE_VERSION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_GENERIC_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_GENERIC_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_GENERIC_TYPE_DESCRIPTION"
              value="type-description"
              c:type="NM_DEVICE_GENERIC_TYPE_DESCRIPTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_INFINIBAND_CARRIER"
              value="carrier"
              c:type="NM_DEVICE_INFINIBAND_CARRIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_INFINIBAND_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_INFINIBAND_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_INTERFACE"
              value="interface"
              c:type="NM_DEVICE_INTERFACE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_IP4_CONFIG"
              value="ip4-config"
              c:type="NM_DEVICE_IP4_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_IP6_CONFIG"
              value="ip6-config"
              c:type="NM_DEVICE_IP6_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_IP_INTERFACE"
              value="ip-interface"
              c:type="NM_DEVICE_IP_INTERFACE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MANAGED" value="managed" c:type="NM_DEVICE_MANAGED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MODEM_CURRENT_CAPABILITIES"
              value="current-capabilities"
              c:type="NM_DEVICE_MODEM_CURRENT_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MODEM_MODEM_CAPABILITIES"
              value="modem-capabilities"
              c:type="NM_DEVICE_MODEM_MODEM_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MTU" value="mtu" c:type="NM_DEVICE_MTU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_OLPC_MESH_ACTIVE_CHANNEL"
              value="active-channel"
              c:type="NM_DEVICE_OLPC_MESH_ACTIVE_CHANNEL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_OLPC_MESH_COMPANION"
              value="companion"
              c:type="NM_DEVICE_OLPC_MESH_COMPANION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_OLPC_MESH_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_OLPC_MESH_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_PHYSICAL_PORT_ID"
              value="physical-port-id"
              c:type="NM_DEVICE_PHYSICAL_PORT_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_PRODUCT" value="product" c:type="NM_DEVICE_PRODUCT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_STATE" value="state" c:type="NM_DEVICE_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_STATE_REASON"
              value="state-reason"
              c:type="NM_DEVICE_STATE_REASON">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_TEAM_CARRIER"
              value="carrier"
              c:type="NM_DEVICE_TEAM_CARRIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_TEAM_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_TEAM_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_TEAM_SLAVES"
              value="slaves"
              c:type="NM_DEVICE_TEAM_SLAVES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_UDI" value="udi" c:type="NM_DEVICE_UDI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VENDOR" value="vendor" c:type="NM_DEVICE_VENDOR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VLAN_CARRIER"
              value="carrier"
              c:type="NM_DEVICE_VLAN_CARRIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VLAN_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_VLAN_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VLAN_PARENT"
              value="parent"
              c:type="NM_DEVICE_VLAN_PARENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VLAN_VLAN_ID"
              value="vlan-id"
              c:type="NM_DEVICE_VLAN_VLAN_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIFI_ACCESS_POINTS"
              value="access-points"
              c:type="NM_DEVICE_WIFI_ACCESS_POINTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIFI_ACTIVE_ACCESS_POINT"
              value="active-access-point"
              c:type="NM_DEVICE_WIFI_ACTIVE_ACCESS_POINT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIFI_BITRATE"
              value="bitrate"
              c:type="NM_DEVICE_WIFI_BITRATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIFI_CAPABILITIES"
              value="wireless-capabilities"
              c:type="NM_DEVICE_WIFI_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIFI_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_WIFI_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIFI_MODE"
              value="mode"
              c:type="NM_DEVICE_WIFI_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIFI_PERMANENT_HW_ADDRESS"
              value="perm-hw-address"
              c:type="NM_DEVICE_WIFI_PERMANENT_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIMAX_ACTIVE_NSP"
              value="active-nsp"
              c:type="NM_DEVICE_WIMAX_ACTIVE_NSP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIMAX_BSID"
              value="bsid"
              c:type="NM_DEVICE_WIMAX_BSID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIMAX_CENTER_FREQUENCY"
              value="center-frequency"
              c:type="NM_DEVICE_WIMAX_CENTER_FREQUENCY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIMAX_CINR"
              value="cinr"
              c:type="NM_DEVICE_WIMAX_CINR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIMAX_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_WIMAX_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIMAX_NSPS"
              value="nsps"
              c:type="NM_DEVICE_WIMAX_NSPS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIMAX_RSSI"
              value="rssi"
              c:type="NM_DEVICE_WIMAX_RSSI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIMAX_TX_POWER"
              value="tx-power"
              c:type="NM_DEVICE_WIMAX_TX_POWER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="DHCP4Config"
           c:symbol-prefix="dhcp4_config"
           c:type="NMDHCP4Config"
           parent="Object"
           glib:type-name="NMDHCP4Config"
           glib:get-type="nm_dhcp4_config_get_type"
           glib:type-struct="DHCP4ConfigClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_dhcp4_config_new">
        <doc xml:space="preserve">Creates a new #NMDHCP4Config.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new configuration</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_one_option"
              c:identifier="nm_dhcp4_config_get_one_option">
        <doc xml:space="preserve">Gets one option by option name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the configuration option's value. This is the internal string used by the
configuration, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDHCP4Config</doc>
            <type name="DHCP4Config" c:type="NMDHCP4Config*"/>
          </instance-parameter>
          <parameter name="option" transfer-ownership="none">
            <doc xml:space="preserve">the option to retrieve</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_options" c:identifier="nm_dhcp4_config_get_options">
        <doc xml:space="preserve">Gets all the options contained in the configuration.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GHashTable containing strings for keys and values.
This is the internal copy used by the configuration, and must not be modified.</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDHCP4Config</doc>
            <type name="DHCP4Config" c:type="NMDHCP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="options" transfer-ownership="none">
        <doc xml:space="preserve">The #GHashTable containing options of the configuration.</doc>
        <type name="GLib.HashTable">
          <type name="utf8"/>
          <type name="GObject.Value"/>
        </type>
      </property>
      <field name="parent">
        <type name="Object" c:type="NMObject"/>
      </field>
    </class>
    <record name="DHCP4ConfigClass"
            c:type="NMDHCP4ConfigClass"
            glib:is-gtype-struct-for="DHCP4Config">
      <field name="parent">
        <type name="ObjectClass" c:type="NMObjectClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <constant name="DHCP4_CONFIG_OPTIONS"
              value="options"
              c:type="NM_DHCP4_CONFIG_OPTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="DHCP6Config"
           c:symbol-prefix="dhcp6_config"
           c:type="NMDHCP6Config"
           parent="Object"
           glib:type-name="NMDHCP6Config"
           glib:get-type="nm_dhcp6_config_get_type"
           glib:type-struct="DHCP6ConfigClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_dhcp6_config_new">
        <doc xml:space="preserve">Creates a new #NMDHCP6Config.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new configuration</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_one_option"
              c:identifier="nm_dhcp6_config_get_one_option">
        <doc xml:space="preserve">Gets one option by option name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the configuration option's value. This is the internal string used by the
configuration, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDHCP6Config</doc>
            <type name="DHCP6Config" c:type="NMDHCP6Config*"/>
          </instance-parameter>
          <parameter name="option" transfer-ownership="none">
            <doc xml:space="preserve">the option to retrieve</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_options" c:identifier="nm_dhcp6_config_get_options">
        <doc xml:space="preserve">Gets all the options contained in the configuration.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GHashTable containing strings for keys and values.
This is the internal copy used by the configuration, and must not be modified.</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDHCP6Config</doc>
            <type name="DHCP6Config" c:type="NMDHCP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="options" transfer-ownership="none">
        <doc xml:space="preserve">The #GHashTable containing options of the configuration.</doc>
        <type name="GLib.HashTable">
          <type name="utf8"/>
          <type name="GObject.Value"/>
        </type>
      </property>
      <field name="parent">
        <type name="Object" c:type="NMObject"/>
      </field>
    </class>
    <record name="DHCP6ConfigClass"
            c:type="NMDHCP6ConfigClass"
            glib:is-gtype-struct-for="DHCP6Config">
      <field name="parent">
        <type name="ObjectClass" c:type="NMObjectClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <constant name="DHCP6_CONFIG_OPTIONS"
              value="options"
              c:type="NM_DHCP6_CONFIG_OPTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="Device"
           c:symbol-prefix="device"
           c:type="NMDevice"
           parent="Object"
           glib:type-name="NMDevice"
           glib:get-type="nm_device_get_type"
           glib:type-struct="DeviceClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_device_new">
        <doc xml:space="preserve">Creates a new #NMDevice.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new device</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="disambiguate_names"
                c:identifier="nm_device_disambiguate_names"
                version="0.9.10">
        <doc xml:space="preserve">Generates a list of short-ish unique presentation names for the
devices in @devices.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the device names</doc>
          <array c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="devices" transfer-ownership="none">
            <doc xml:space="preserve">an array of #NMDevice</doc>
            <array length="1" zero-terminated="0" c:type="NMDevice**">
              <type name="Device" c:type="NMDevice*"/>
            </array>
          </parameter>
          <parameter name="num_devices" transfer-ownership="none">
            <doc xml:space="preserve">length of @devices</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="connection_compatible"
                      invoker="connection_compatible"
                      throws="1">
        <doc xml:space="preserve">Validates a given connection for a given #NMDevice object and returns
whether the connection may be activated with the device. For example if
@device is a Wi-Fi device that supports only WEP encryption, the connection
will only be valid if it is a Wi-Fi connection which describes a WEP or open
network, and will not be valid if it describes a WPA network, or if it is
an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
device.

This function does the same as nm_device_connection_valid(), i.e. checking
compatibility of the given device and connection. But, in addition, it sets
GError when FALSE is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection may be activated with this device, %FALSE
if is incompatible with the device's capabilities and characteristics.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">an #NMDevice to validate @connection against</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">an #NMConnection to validate against @device</doc>
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_hw_address"
                      invoker="get_hw_address"
                      version="0.9.10">
        <doc xml:space="preserve">Gets the current a hardware address (MAC) for the @device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current MAC of the device, or %NULL.
This is the internal string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_setting_type"
                      invoker="get_setting_type"
                      version="0.9.10">
        <doc xml:space="preserve">Gets the (primary) #NMSetting subtype associated with connections
that can be used on @device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@device's associated #NMSetting type</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">an #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_type_description"
                      invoker="get_type_description"
                      version="0.9.10">
        <doc xml:space="preserve">Gets a (non-localized) description of the type of device that
@device is.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type description of the device. This is the internal
string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="state_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="new_state" transfer-ownership="none">
            <type name="NetworkManager.DeviceState" c:type="NMDeviceState"/>
          </parameter>
          <parameter name="old_state" transfer-ownership="none">
            <type name="NetworkManager.DeviceState" c:type="NMDeviceState"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <type name="NetworkManager.DeviceStateReason"
                  c:type="NMDeviceStateReason"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="connection_compatible"
              c:identifier="nm_device_connection_compatible"
              throws="1">
        <doc xml:space="preserve">Validates a given connection for a given #NMDevice object and returns
whether the connection may be activated with the device. For example if
@device is a Wi-Fi device that supports only WEP encryption, the connection
will only be valid if it is a Wi-Fi connection which describes a WEP or open
network, and will not be valid if it describes a WPA network, or if it is
an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
device.

This function does the same as nm_device_connection_valid(), i.e. checking
compatibility of the given device and connection. But, in addition, it sets
GError when FALSE is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection may be activated with this device, %FALSE
if is incompatible with the device's capabilities and characteristics.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">an #NMDevice to validate @connection against</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">an #NMConnection to validate against @device</doc>
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connection_valid"
              c:identifier="nm_device_connection_valid">
        <doc xml:space="preserve">Validates a given connection for a given #NMDevice object and returns
whether the connection may be activated with the device. For example if
@device is a Wi-Fi device that supports only WEP encryption, the connection
will only be valid if it is a Wi-Fi connection which describes a WEP or open
network, and will not be valid if it describes a WPA network, or if it is
an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection may be activated with this device, %FALSE
if is incompatible with the device's capabilities and characteristics.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">an #NMDevice to validate @connection against</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">an #NMConnection to validate against @device</doc>
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete" c:identifier="nm_device_delete" version="1.0">
        <doc xml:space="preserve">Deletes the software device. Hardware devices can't be deleted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">callback to be called when delete
operation completes</doc>
            <type name="DeviceCallbackFn" c:type="NMDeviceCallbackFn"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">caller-specific data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="disconnect" c:identifier="nm_device_disconnect">
        <doc xml:space="preserve">Disconnects the device if currently connected, and prevents the device from
automatically connecting to networks until the next manual network connection
request.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">callback to be called when disconnect
operation completes</doc>
            <type name="DeviceCallbackFn" c:type="NMDeviceCallbackFn"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">caller-specific data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="filter_connections"
              c:identifier="nm_device_filter_connections">
        <doc xml:space="preserve">Filters a given list of connections for a given #NMDevice object and return
connections which may be activated with the device. For example if @device
is a Wi-Fi device that supports only WEP encryption, the returned list will
contain any Wi-Fi connections in @connections that allow connection to
unencrypted or WEP-enabled SSIDs.  The returned list will not contain
Ethernet, Bluetooth, Wi-Fi WPA connections, or any other connection that is
incompatible with the device. To get the full list of connections see
nm_remote_settings_list_connections().</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a
list of #NMConnection objects that could be activated with the given @device.
The elements of the list are owned by their creator and should not be freed
by the caller, but the returned list itself is owned by the caller and should
be freed with g_slist_free() when it is no longer required.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="NetworkManager.Connection"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">an #NMDevice to filter connections for</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="connections" transfer-ownership="none">
            <doc xml:space="preserve">a list of #NMConnection objects to filter</doc>
            <type name="GLib.SList" c:type="const GSList*">
              <type name="NetworkManager.Connection"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="get_active_connection"
              c:identifier="nm_device_get_active_connection">
        <doc xml:space="preserve">Gets the #NMActiveConnection object which owns this device during activation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMActiveConnection or %NULL if the device is
not part of an active connection</doc>
          <type name="ActiveConnection" c:type="NMActiveConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_autoconnect" c:identifier="nm_device_get_autoconnect">
        <doc xml:space="preserve">Whether the #NMDevice can be autoconnected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the device is allowed to be autoconnected</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_available_connections"
              c:identifier="nm_device_get_available_connections"
              version="0.9.8">
        <doc xml:space="preserve">Gets the #NMRemoteConnections currently known to the daemon that could
be activated on @device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GPtrArray
containing #NMRemoteConnections. This is the internal copy used by
the connection, and must not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="RemoteConnection"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_capabilities"
              c:identifier="nm_device_get_capabilities">
        <doc xml:space="preserve">Gets the device' capabilities.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the capabilities</doc>
          <type name="NetworkManager.DeviceCapabilities"
                c:type="NMDeviceCapabilities"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_description"
              c:identifier="nm_device_get_description"
              version="0.9.10">
        <doc xml:space="preserve">Gets a description of @device, based on its vendor and product names.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a description of @device. If either the vendor or the
  product name is unknown, this returns the interface name.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">an #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_device_type" c:identifier="nm_device_get_device_type">
        <doc xml:space="preserve">Returns the numeric type of the #NMDevice, ie Ethernet, Wi-Fi, etc.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the device type</doc>
          <type name="NetworkManager.DeviceType" c:type="NMDeviceType"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dhcp4_config"
              c:identifier="nm_device_get_dhcp4_config">
        <doc xml:space="preserve">Gets the current #NMDHCP4Config associated with the #NMDevice.

Note that as of NetworkManager 0.9.10, you can alternatively use
nm_active_connection_get_dhcp4_config(), which also works with VPN
connections.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMDHCP4Config or %NULL if the device is not activated or not
using DHCP.</doc>
          <type name="DHCP4Config" c:type="NMDHCP4Config*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dhcp6_config"
              c:identifier="nm_device_get_dhcp6_config">
        <doc xml:space="preserve">Gets the current #NMDHCP6Config associated with the #NMDevice.

Note that as of NetworkManager 0.9.10, you can alternatively use
nm_active_connection_get_dhcp6_config(), which also works with VPN
connections.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMDHCP6Config or %NULL if the device is not activated or not
using DHCP.</doc>
          <type name="DHCP6Config" c:type="NMDHCP6Config*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_driver" c:identifier="nm_device_get_driver">
        <doc xml:space="preserve">Gets the driver of the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the driver of the device. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_driver_version"
              c:identifier="nm_device_get_driver_version">
        <doc xml:space="preserve">Gets the driver version of the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the version of the device driver. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_firmware_missing"
              c:identifier="nm_device_get_firmware_missing">
        <doc xml:space="preserve">Indicates that firmware required for the device's operation is likely
to be missing.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if firmware required for the device's operation is likely
to be missing.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_firmware_version"
              c:identifier="nm_device_get_firmware_version">
        <doc xml:space="preserve">Gets the firmware version of the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the firmware version of the device. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_get_hw_address"
              version="0.9.10">
        <doc xml:space="preserve">Gets the current a hardware address (MAC) for the @device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current MAC of the device, or %NULL.
This is the internal string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_iface" c:identifier="nm_device_get_iface">
        <doc xml:space="preserve">Gets the interface name of the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the interface of the device. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ip4_config" c:identifier="nm_device_get_ip4_config">
        <doc xml:space="preserve">Gets the current #NMIP4Config associated with the #NMDevice.

Note that as of NetworkManager 0.9.10, you can alternatively use
nm_active_connection_get_ip4_config(), which also works with VPN
connections.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMIP4Config or %NULL if the device is not activated.</doc>
          <type name="IP4Config" c:type="NMIP4Config*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ip6_config" c:identifier="nm_device_get_ip6_config">
        <doc xml:space="preserve">Gets the current #NMIP6Config associated with the #NMDevice.

Note that as of NetworkManager 0.9.10, you can alternatively use
nm_active_connection_get_ip6_config(), which also works with VPN
connections.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMIP6Config or %NULL if the device is not activated.</doc>
          <type name="IP6Config" c:type="NMIP6Config*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ip_iface" c:identifier="nm_device_get_ip_iface">
        <doc xml:space="preserve">Gets the IP interface name of the #NMDevice over which IP traffic flows
when the device is in the ACTIVATED state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IP traffic interface of the device. This is the internal string
used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_managed" c:identifier="nm_device_get_managed">
        <doc xml:space="preserve">Whether the #NMDevice is managed by NetworkManager.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the device is managed by NetworkManager</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mtu" c:identifier="nm_device_get_mtu" version="0.9.10">
        <doc xml:space="preserve">Gets the  MTU of the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the MTU of the device.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_physical_port_id"
              c:identifier="nm_device_get_physical_port_id"
              version="0.9.10">
        <doc xml:space="preserve">Gets the physical port ID of the #NMDevice. If non-%NULL, this is
an opaque string that can be used to recognize when
seemingly-unrelated #NMDevices are actually just different virtual
ports on a single physical port. (Eg, NPAR / SR-IOV.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the physical port ID of the device, or %NULL if the port
  ID is unknown. This is the internal string used by the device and
  must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_product" c:identifier="nm_device_get_product">
        <doc xml:space="preserve">Gets the product string of the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the product name of the device. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_type"
              c:identifier="nm_device_get_setting_type"
              version="0.9.10">
        <doc xml:space="preserve">Gets the (primary) #NMSetting subtype associated with connections
that can be used on @device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@device's associated #NMSetting type</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">an #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_state" c:identifier="nm_device_get_state">
        <doc xml:space="preserve">Gets the current #NMDevice state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current device state</doc>
          <type name="NetworkManager.DeviceState" c:type="NMDeviceState"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_state_reason"
              c:identifier="nm_device_get_state_reason">
        <doc xml:space="preserve">Gets the current #NMDevice state (return value) and the reason for entering
the state (@reason argument).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current device state</doc>
          <type name="NetworkManager.DeviceState" c:type="NMDeviceState"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="reason"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">location to store reason (#NMDeviceStateReason), or %NULL</doc>
            <type name="NetworkManager.DeviceStateReason"
                  c:type="NMDeviceStateReason*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_type_description"
              c:identifier="nm_device_get_type_description"
              version="0.9.10">
        <doc xml:space="preserve">Gets a (non-localized) description of the type of device that
@device is.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type description of the device. This is the internal
string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_udi" c:identifier="nm_device_get_udi">
        <doc xml:space="preserve">Gets the Unique Device Identifier of the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the Unique Device Identifier of the device.  This identifier may be
used to gather more information about the device from various operating
system services like udev or sysfs.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vendor" c:identifier="nm_device_get_vendor">
        <doc xml:space="preserve">Gets the vendor string of the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the vendor name of the device. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_software"
              c:identifier="nm_device_is_software"
              version="1.0">
        <doc xml:space="preserve">Whether the device is a software device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @device is a software device, %FALSE if it is a hardware device.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_autoconnect" c:identifier="nm_device_set_autoconnect">
        <doc xml:space="preserve">Enables or disables automatic activation of the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="autoconnect" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to enable autoconnecting</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="active-connection" transfer-ownership="none">
        <doc xml:space="preserve">The #NMActiveConnection object that "owns" this device during activation.</doc>
        <type name="ActiveConnection"/>
      </property>
      <property name="autoconnect" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether the device can auto-activate a connection.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="available-connections"
                version="0.9.8"
                transfer-ownership="none">
        <doc xml:space="preserve">The available connections (#NMRemoteConnection) of the device</doc>
        <type name="ObjectArray"/>
      </property>
      <property name="capabilities" transfer-ownership="none">
        <doc xml:space="preserve">The capabilities of the device.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="device-type" transfer-ownership="none">
        <doc xml:space="preserve">The numeric type of the device.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="dhcp4-config" transfer-ownership="none">
        <doc xml:space="preserve">The #NMDHCP4Config of the device.</doc>
        <type name="DHCP4Config"/>
      </property>
      <property name="dhcp6-config" transfer-ownership="none">
        <doc xml:space="preserve">The #NMDHCP6Config of the device.</doc>
        <type name="DHCP6Config"/>
      </property>
      <property name="driver" transfer-ownership="none">
        <doc xml:space="preserve">The driver of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="driver-version" transfer-ownership="none">
        <doc xml:space="preserve">The version of the device driver.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="firmware-missing" transfer-ownership="none">
        <doc xml:space="preserve">When %TRUE indicates the device is likely missing firmware required
for its operation.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="firmware-version" transfer-ownership="none">
        <doc xml:space="preserve">The firmware version of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="interface" transfer-ownership="none">
        <doc xml:space="preserve">The interface of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="ip-interface" transfer-ownership="none">
        <doc xml:space="preserve">The IP interface of the device which should be used for all IP-related
operations like addressing and routing.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="ip4-config" transfer-ownership="none">
        <doc xml:space="preserve">The #NMIP4Config of the device.</doc>
        <type name="IP4Config"/>
      </property>
      <property name="ip6-config" transfer-ownership="none">
        <doc xml:space="preserve">The #NMIP6Config of the device.</doc>
        <type name="IP6Config"/>
      </property>
      <property name="managed" transfer-ownership="none">
        <doc xml:space="preserve">Whether the device is managed by NetworkManager.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="mtu" version="0.9.10" transfer-ownership="none">
        <doc xml:space="preserve">The MTU of the device.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="physical-port-id"
                version="0.9.10"
                transfer-ownership="none">
        <doc xml:space="preserve">The physical port ID of the device. (See
nm_device_get_physical_port_id().)</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="product" transfer-ownership="none">
        <doc xml:space="preserve">The product string of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="state" transfer-ownership="none">
        <doc xml:space="preserve">The state of the device.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="state-reason"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:space="preserve">The state and reason of the device.</doc>
        <type/>
      </property>
      <property name="udi" transfer-ownership="none">
        <doc xml:space="preserve">An operating-system specific device hardware identifier; this is not
unique to a specific hardware device across reboots or hotplugs.  It
is an opaque string which for some device types (Bluetooth, Modem)
contains an identifier provided by the underlying hardware service daemon
such as Bluez or ModemManager, and clients can use this property to
request more information about the device from those services.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="vendor" transfer-ownership="none">
        <doc xml:space="preserve">The vendor string of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Object" c:type="NMObject"/>
      </field>
      <glib:signal name="state-changed" when="first">
        <doc xml:space="preserve">Notifies the state change of a #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="new_state" transfer-ownership="none">
            <doc xml:space="preserve">the new state of the device</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="old_state" transfer-ownership="none">
            <doc xml:space="preserve">the previous state of the device</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:space="preserve">the reason describing the state change</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <class name="DeviceAdsl"
           c:symbol-prefix="device_adsl"
           c:type="NMDeviceAdsl"
           parent="Device"
           glib:type-name="NMDeviceAdsl"
           glib:get-type="nm_device_adsl_get_type"
           glib:type-struct="DeviceAdslClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_device_adsl_new">
        <doc xml:space="preserve">Creates a new #NMDeviceAdsl.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new device</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_carrier" c:identifier="nm_device_adsl_get_carrier">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the device has carrier</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceAdsl</doc>
            <type name="DeviceAdsl" c:type="NMDeviceAdsl*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="carrier" transfer-ownership="none">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceAdslClass"
            c:type="NMDeviceAdslClass"
            glib:is-gtype-struct-for="DeviceAdsl">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="DeviceAdslError"
                 glib:type-name="NMDeviceAdslError"
                 glib:get-type="nm_device_adsl_error_get_type"
                 c:type="NMDeviceAdslError"
                 glib:error-domain="nm-device-adsl-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_DEVICE_ADSL_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="NotAdslConnection"
              value="1"
              c:identifier="NM_DEVICE_ADSL_ERROR_NOT_ADSL_CONNECTION"
              glib:nick="NotAdslConnection">
        <doc xml:space="preserve">the connection was not of ADSL type</doc>
      </member>
      <member name="InvalidAdslConnection"
              value="2"
              c:identifier="NM_DEVICE_ADSL_ERROR_INVALID_ADSL_CONNECTION"
              glib:nick="InvalidAdslConnection">
        <doc xml:space="preserve">the ADSL connection was invalid</doc>
      </member>
      <function name="quark" c:identifier="nm_device_adsl_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMDeviceAdsl if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMDeviceAdsl errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="DeviceBond"
           c:symbol-prefix="device_bond"
           c:type="NMDeviceBond"
           parent="Device"
           glib:type-name="NMDeviceBond"
           glib:get-type="nm_device_bond_get_type"
           glib:type-struct="DeviceBondClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_device_bond_new">
        <doc xml:space="preserve">Creates a new #NMDeviceBond.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new device</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_carrier" c:identifier="nm_device_bond_get_carrier">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the device has carrier</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceBond</doc>
            <type name="DeviceBond" c:type="NMDeviceBond*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_bond_get_hw_address">
        <doc xml:space="preserve">Gets the hardware (MAC) address of the #NMDeviceBond</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceBond</doc>
            <type name="DeviceBond" c:type="NMDeviceBond*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_slaves"
              c:identifier="nm_device_bond_get_slaves"
              version="0.9.6.4">
        <doc xml:space="preserve">Gets the devices currently slaved to @device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GPtrArray containing
#NMDevices that are slaves of @device. This is the internal
copy used by the device, and must not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="Device"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceBond</doc>
            <type name="DeviceBond" c:type="NMDeviceBond*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="carrier" transfer-ownership="none">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:space="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="slaves" version="0.9.8" transfer-ownership="none">
        <doc xml:space="preserve">The devices (#NMDevice) slaved to the bond device.</doc>
        <type name="ObjectArray"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceBondClass"
            c:type="NMDeviceBondClass"
            glib:is-gtype-struct-for="DeviceBond">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="DeviceBondError"
                 glib:type-name="NMDeviceBondError"
                 glib:get-type="nm_device_bond_error_get_type"
                 c:type="NMDeviceBondError"
                 glib:error-domain="nm-device-bond-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_DEVICE_BOND_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="NotBondConnection"
              value="1"
              c:identifier="NM_DEVICE_BOND_ERROR_NOT_BOND_CONNECTION"
              glib:nick="NotBondConnection">
        <doc xml:space="preserve">the connection was not of bond type</doc>
      </member>
      <member name="InvalidBondConnection"
              value="2"
              c:identifier="NM_DEVICE_BOND_ERROR_INVALID_BOND_CONNECTION"
              glib:nick="InvalidBondConnection">
        <doc xml:space="preserve">the bond connection was invalid</doc>
      </member>
      <member name="InterfaceMismatch"
              value="3"
              c:identifier="NM_DEVICE_BOND_ERROR_INTERFACE_MISMATCH"
              glib:nick="InterfaceMismatch">
        <doc xml:space="preserve">the interfaces of the connection and the device mismatched</doc>
      </member>
      <function name="quark" c:identifier="nm_device_bond_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMDeviceBond if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMDeviceBond errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="DeviceBridge"
           c:symbol-prefix="device_bridge"
           c:type="NMDeviceBridge"
           parent="Device"
           glib:type-name="NMDeviceBridge"
           glib:get-type="nm_device_bridge_get_type"
           glib:type-struct="DeviceBridgeClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new"
                   c:identifier="nm_device_bridge_new"
                   version="0.9.8">
        <doc xml:space="preserve">Creates a new #NMDeviceBridge.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new device</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_carrier"
              c:identifier="nm_device_bridge_get_carrier"
              version="0.9.8">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the device has carrier</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceBridge</doc>
            <type name="DeviceBridge" c:type="NMDeviceBridge*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_bridge_get_hw_address"
              version="0.9.8">
        <doc xml:space="preserve">Gets the hardware (MAC) address of the #NMDeviceBridge</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceBridge</doc>
            <type name="DeviceBridge" c:type="NMDeviceBridge*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_slaves"
              c:identifier="nm_device_bridge_get_slaves"
              version="0.9.8">
        <doc xml:space="preserve">Gets the devices currently slaved to @device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GPtrArray containing
#NMDevices that are slaves of @device. This is the internal
copy used by the device, and must not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="Device"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceBridge</doc>
            <type name="DeviceBridge" c:type="NMDeviceBridge*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="carrier" version="0.9.8" transfer-ownership="none">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="hw-address" version="0.9.8" transfer-ownership="none">
        <doc xml:space="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="slaves" version="0.9.8" transfer-ownership="none">
        <doc xml:space="preserve">The devices (#NMDevice) slaved to the bridge device.</doc>
        <type name="ObjectArray"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceBridgeClass"
            c:type="NMDeviceBridgeClass"
            glib:is-gtype-struct-for="DeviceBridge">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="DeviceBridgeError"
                 version="0.9.8"
                 glib:type-name="NMDeviceBridgeError"
                 glib:get-type="nm_device_bridge_error_get_type"
                 c:type="NMDeviceBridgeError"
                 glib:error-domain="nm-device-bridge-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_DEVICE_BRIDGE_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="NotBridgeConnection"
              value="1"
              c:identifier="NM_DEVICE_BRIDGE_ERROR_NOT_BRIDGE_CONNECTION"
              glib:nick="NotBridgeConnection">
        <doc xml:space="preserve">the connection was not of bridge type</doc>
      </member>
      <member name="InvalidBridgeConnection"
              value="2"
              c:identifier="NM_DEVICE_BRIDGE_ERROR_INVALID_BRIDGE_CONNECTION"
              glib:nick="InvalidBridgeConnection">
        <doc xml:space="preserve">the bridge connection was invalid</doc>
      </member>
      <member name="InterfaceMismatch"
              value="3"
              c:identifier="NM_DEVICE_BRIDGE_ERROR_INTERFACE_MISMATCH"
              glib:nick="InterfaceMismatch">
        <doc xml:space="preserve">the interfaces of the connection and the device mismatched</doc>
      </member>
      <function name="quark"
                c:identifier="nm_device_bridge_error_quark"
                version="0.9.8">
        <doc xml:space="preserve">Registers an error quark for #NMDeviceBridge if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMDeviceBridge errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="DeviceBt"
           c:symbol-prefix="device_bt"
           c:type="NMDeviceBt"
           parent="Device"
           glib:type-name="NMDeviceBt"
           glib:get-type="nm_device_bt_get_type"
           glib:type-struct="DeviceBtClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_device_bt_new">
        <doc xml:space="preserve">Creates a new #NMDeviceBt.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new device</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_capabilities"
              c:identifier="nm_device_bt_get_capabilities">
        <doc xml:space="preserve">Returns the Bluetooth device's usable capabilities.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a combination of #NMBluetoothCapabilities</doc>
          <type name="NetworkManager.BluetoothCapabilities"
                c:type="NMBluetoothCapabilities"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceBt</doc>
            <type name="DeviceBt" c:type="NMDeviceBt*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address" c:identifier="nm_device_bt_get_hw_address">
        <doc xml:space="preserve">Gets the hardware (MAC) address of the #NMDeviceBt</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceBt</doc>
            <type name="DeviceBt" c:type="NMDeviceBt*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="nm_device_bt_get_name">
        <doc xml:space="preserve">Gets the name of the #NMDeviceBt.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of the device</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceBt</doc>
            <type name="DeviceBt" c:type="NMDeviceBt*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="bt-capabilities" transfer-ownership="none">
        <doc xml:space="preserve">The device's bluetooth capabilities, a combination of #NMBluetoothCapabilities.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:space="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="name" transfer-ownership="none">
        <doc xml:space="preserve">The name of the bluetooth device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceBtClass"
            c:type="NMDeviceBtClass"
            glib:is-gtype-struct-for="DeviceBt">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="DeviceBtError"
                 glib:type-name="NMDeviceBtError"
                 glib:get-type="nm_device_bt_error_get_type"
                 c:type="NMDeviceBtError"
                 glib:error-domain="nm-device-bt-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_DEVICE_BT_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="NotBtConnection"
              value="1"
              c:identifier="NM_DEVICE_BT_ERROR_NOT_BT_CONNECTION"
              glib:nick="NotBtConnection">
        <doc xml:space="preserve">the connection was not of bluetooth type</doc>
      </member>
      <member name="InvalidBtConnection"
              value="2"
              c:identifier="NM_DEVICE_BT_ERROR_INVALID_BT_CONNECTION"
              glib:nick="InvalidBtConnection">
        <doc xml:space="preserve">the bluetooth connection was invalid</doc>
      </member>
      <member name="InvalidDeviceMac"
              value="3"
              c:identifier="NM_DEVICE_BT_ERROR_INVALID_DEVICE_MAC"
              glib:nick="InvalidDeviceMac">
        <doc xml:space="preserve">the device's MAC was invalid</doc>
      </member>
      <member name="MacMismatch"
              value="4"
              c:identifier="NM_DEVICE_BT_ERROR_MAC_MISMATCH"
              glib:nick="MacMismatch">
        <doc xml:space="preserve">the MACs of the connection and the device mismatched</doc>
      </member>
      <member name="MissingDeviceCaps"
              value="5"
              c:identifier="NM_DEVICE_BT_ERROR_MISSING_DEVICE_CAPS"
              glib:nick="MissingDeviceCaps">
        <doc xml:space="preserve">the device missed required capabilities</doc>
      </member>
      <function name="quark" c:identifier="nm_device_bt_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMDeviceBt if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMDeviceBt errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <callback name="DeviceCallbackFn" c:type="NMDeviceCallbackFn">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="device" transfer-ownership="none">
          <type name="Device" c:type="NMDevice*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="DeviceClass"
            c:type="NMDeviceClass"
            glib:is-gtype-struct-for="Device">
      <field name="parent">
        <type name="ObjectClass" c:type="NMObjectClass"/>
      </field>
      <field name="state_changed">
        <callback name="state_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="device" transfer-ownership="none">
              <type name="Device" c:type="NMDevice*"/>
            </parameter>
            <parameter name="new_state" transfer-ownership="none">
              <type name="NetworkManager.DeviceState" c:type="NMDeviceState"/>
            </parameter>
            <parameter name="old_state" transfer-ownership="none">
              <type name="NetworkManager.DeviceState" c:type="NMDeviceState"/>
            </parameter>
            <parameter name="reason" transfer-ownership="none">
              <type name="NetworkManager.DeviceStateReason"
                    c:type="NMDeviceStateReason"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="connection_compatible">
        <callback name="connection_compatible" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the connection may be activated with this device, %FALSE
if is incompatible with the device's capabilities and characteristics.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="device" transfer-ownership="none">
              <doc xml:space="preserve">an #NMDevice to validate @connection against</doc>
              <type name="Device" c:type="NMDevice*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">an #NMConnection to validate against @device</doc>
              <type name="NetworkManager.Connection" c:type="NMConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_type_description">
        <callback name="get_type_description">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the type description of the device. This is the internal
string used by the device, and must not be modified.</doc>
            <type name="utf8" c:type="const char*"/>
          </return-value>
          <parameters>
            <parameter name="device" transfer-ownership="none">
              <doc xml:space="preserve">a #NMDevice</doc>
              <type name="Device" c:type="NMDevice*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_hw_address">
        <callback name="get_hw_address">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the current MAC of the device, or %NULL.
This is the internal string used by the device, and must not be modified.</doc>
            <type name="utf8" c:type="const char*"/>
          </return-value>
          <parameters>
            <parameter name="device" transfer-ownership="none">
              <doc xml:space="preserve">a #NMDevice</doc>
              <type name="Device" c:type="NMDevice*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_setting_type">
        <callback name="get_setting_type">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">@device's associated #NMSetting type</doc>
            <type name="GType" c:type="GType"/>
          </return-value>
          <parameters>
            <parameter name="device" transfer-ownership="none">
              <doc xml:space="preserve">an #NMDevice</doc>
              <type name="Device" c:type="NMDevice*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <callback name="DeviceDeactivateFn" c:type="NMDeviceDeactivateFn">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="device" transfer-ownership="none">
          <type name="Device" c:type="NMDevice*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="DeviceError"
                 glib:type-name="NMDeviceError"
                 glib:get-type="nm_device_error_get_type"
                 c:type="NMDeviceError"
                 glib:error-domain="nm-device-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_DEVICE_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InterfaceMismatch"
              value="1"
              c:identifier="NM_DEVICE_ERROR_INTERFACE_MISMATCH"
              glib:nick="InterfaceMismatch">
        <doc xml:space="preserve">the interface names of the connection and the
  device mismatched</doc>
      </member>
      <function name="quark"
                c:identifier="nm_device_error_quark"
                version="0.9.10">
        <doc xml:space="preserve">Registers an error quark for #NMDevice if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMDevice errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="DeviceEthernet"
           c:symbol-prefix="device_ethernet"
           c:type="NMDeviceEthernet"
           parent="Device"
           glib:type-name="NMDeviceEthernet"
           glib:get-type="nm_device_ethernet_get_type"
           glib:type-struct="DeviceEthernetClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_device_ethernet_new">
        <doc xml:space="preserve">Creates a new #NMDeviceEthernet.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new device</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_carrier" c:identifier="nm_device_ethernet_get_carrier">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the device has carrier</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceEthernet</doc>
            <type name="DeviceEthernet" c:type="NMDeviceEthernet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_ethernet_get_hw_address">
        <doc xml:space="preserve">Gets the active hardware (MAC) address of the #NMDeviceEthernet</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the active hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceEthernet</doc>
            <type name="DeviceEthernet" c:type="NMDeviceEthernet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_permanent_hw_address"
              c:identifier="nm_device_ethernet_get_permanent_hw_address">
        <doc xml:space="preserve">Gets the permanent hardware (MAC) address of the #NMDeviceEthernet</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the permanent hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceEthernet</doc>
            <type name="DeviceEthernet" c:type="NMDeviceEthernet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_speed" c:identifier="nm_device_ethernet_get_speed">
        <doc xml:space="preserve">Gets the speed of the #NMDeviceEthernet.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the speed of the device</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceEthernet</doc>
            <type name="DeviceEthernet" c:type="NMDeviceEthernet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="carrier" transfer-ownership="none">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:space="preserve">The active hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="perm-hw-address" transfer-ownership="none">
        <doc xml:space="preserve">The permanent hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="speed" transfer-ownership="none">
        <doc xml:space="preserve">The speed of the device.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceEthernetClass"
            c:type="NMDeviceEthernetClass"
            glib:is-gtype-struct-for="DeviceEthernet">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="DeviceEthernetError"
                 glib:type-name="NMDeviceEthernetError"
                 glib:get-type="nm_device_ethernet_error_get_type"
                 c:type="NMDeviceEthernetError"
                 glib:error-domain="nm-device-ethernet-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_DEVICE_ETHERNET_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="NotEthernetConnection"
              value="1"
              c:identifier="NM_DEVICE_ETHERNET_ERROR_NOT_ETHERNET_CONNECTION"
              glib:nick="NotEthernetConnection">
        <doc xml:space="preserve">the connection was not of Ethernet or PPPoE type</doc>
      </member>
      <member name="InvalidEthernetConnection"
              value="2"
              c:identifier="NM_DEVICE_ETHERNET_ERROR_INVALID_ETHERNET_CONNECTION"
              glib:nick="InvalidEthernetConnection">
        <doc xml:space="preserve">the Ethernet connection was invalid</doc>
      </member>
      <member name="InvalidDeviceMac"
              value="3"
              c:identifier="NM_DEVICE_ETHERNET_ERROR_INVALID_DEVICE_MAC"
              glib:nick="InvalidDeviceMac">
        <doc xml:space="preserve">the device's MAC was invalid</doc>
      </member>
      <member name="MacMismatch"
              value="4"
              c:identifier="NM_DEVICE_ETHERNET_ERROR_MAC_MISMATCH"
              glib:nick="MacMismatch">
        <doc xml:space="preserve">the MACs of the connection and the device mismatched</doc>
      </member>
      <function name="quark" c:identifier="nm_device_ethernet_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMDeviceEthernet if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMDeviceEthernet errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="DeviceGeneric"
           c:symbol-prefix="device_generic"
           c:type="NMDeviceGeneric"
           parent="Device"
           glib:type-name="NMDeviceGeneric"
           glib:get-type="nm_device_generic_get_type"
           glib:type-struct="DeviceGenericClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new"
                   c:identifier="nm_device_generic_new"
                   version="0.9.10">
        <doc xml:space="preserve">Creates a new #NMDeviceGeneric.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new device</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_hw_address"
              c:identifier="nm_device_generic_get_hw_address"
              version="0.9.10">
        <doc xml:space="preserve">Gets the hardware address of the #NMDeviceGeneric</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceGeneric</doc>
            <type name="DeviceGeneric" c:type="NMDeviceGeneric*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:space="preserve">The hardware address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="type-description" transfer-ownership="none">
        <doc xml:space="preserve">A description of the specific type of device this is, or %NULL
if not known.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceGenericClass"
            c:type="NMDeviceGenericClass"
            glib:is-gtype-struct-for="DeviceGeneric">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="DeviceGenericError"
                 glib:type-name="NMDeviceGenericError"
                 glib:get-type="nm_device_generic_error_get_type"
                 c:type="NMDeviceGenericError"
                 glib:error-domain="nm-device-generic-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_DEVICE_GENERIC_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="NotGenericConnection"
              value="1"
              c:identifier="NM_DEVICE_GENERIC_ERROR_NOT_GENERIC_CONNECTION"
              glib:nick="NotGenericConnection">
        <doc xml:space="preserve">the connection was not of generic type</doc>
      </member>
      <member name="MissingInterfaceName"
              value="2"
              c:identifier="NM_DEVICE_GENERIC_ERROR_MISSING_INTERFACE_NAME"
              glib:nick="MissingInterfaceName">
        <doc xml:space="preserve">the connection did not specify the interface name</doc>
      </member>
      <function name="quark"
                c:identifier="nm_device_generic_error_quark"
                version="0.9.10">
        <doc xml:space="preserve">Registers an error quark for #NMDeviceGeneric if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMDeviceGeneric errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="DeviceInfiniband"
           c:symbol-prefix="device_infiniband"
           c:type="NMDeviceInfiniband"
           parent="Device"
           glib:type-name="NMDeviceInfiniband"
           glib:get-type="nm_device_infiniband_get_type"
           glib:type-struct="DeviceInfinibandClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_device_infiniband_new">
        <doc xml:space="preserve">Creates a new #NMDeviceInfiniband.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new device</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_carrier"
              c:identifier="nm_device_infiniband_get_carrier">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the device has carrier</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceInfiniband</doc>
            <type name="DeviceInfiniband" c:type="NMDeviceInfiniband*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_infiniband_get_hw_address">
        <doc xml:space="preserve">Gets the hardware (MAC) address of the #NMDeviceInfiniband</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceInfiniband</doc>
            <type name="DeviceInfiniband" c:type="NMDeviceInfiniband*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="carrier" transfer-ownership="none">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:space="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceInfinibandClass"
            c:type="NMDeviceInfinibandClass"
            glib:is-gtype-struct-for="DeviceInfiniband">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="DeviceInfinibandError"
                 glib:type-name="NMDeviceInfinibandError"
                 glib:get-type="nm_device_infiniband_error_get_type"
                 c:type="NMDeviceInfinibandError"
                 glib:error-domain="nm-device-infiniband-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_DEVICE_INFINIBAND_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="NotInfinibandConnection"
              value="1"
              c:identifier="NM_DEVICE_INFINIBAND_ERROR_NOT_INFINIBAND_CONNECTION"
              glib:nick="NotInfinibandConnection">
        <doc xml:space="preserve">the connection was not of InfiniBand type</doc>
      </member>
      <member name="InvalidInfinibandConnection"
              value="2"
              c:identifier="NM_DEVICE_INFINIBAND_ERROR_INVALID_INFINIBAND_CONNECTION"
              glib:nick="InvalidInfinibandConnection">
        <doc xml:space="preserve">the InfiniBand connection was invalid</doc>
      </member>
      <member name="InvalidDeviceMac"
              value="3"
              c:identifier="NM_DEVICE_INFINIBAND_ERROR_INVALID_DEVICE_MAC"
              glib:nick="InvalidDeviceMac">
        <doc xml:space="preserve">the device's MAC was invalid</doc>
      </member>
      <member name="MacMismatch"
              value="4"
              c:identifier="NM_DEVICE_INFINIBAND_ERROR_MAC_MISMATCH"
              glib:nick="MacMismatch">
        <doc xml:space="preserve">the MACs of the connection and the device mismatched</doc>
      </member>
      <function name="quark" c:identifier="nm_device_infiniband_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMDeviceInfiniband if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMDeviceInfiniband errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="DeviceModem"
           c:symbol-prefix="device_modem"
           c:type="NMDeviceModem"
           parent="Device"
           glib:type-name="NMDeviceModem"
           glib:get-type="nm_device_modem_get_type"
           glib:type-struct="DeviceModemClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <method name="get_current_capabilities"
              c:identifier="nm_device_modem_get_current_capabilities">
        <doc xml:space="preserve">Returns a bitfield of the generic access technology families the modem
supports without a firmware reload or reinitialization.  This value
represents the network types the modem can immediately connect to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the generic access technology families the modem supports without
a firmware reload or other reinitialization</doc>
          <type name="NetworkManager.DeviceModemCapabilities"
                c:type="NMDeviceModemCapabilities"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceModem</doc>
            <type name="DeviceModem" c:type="NMDeviceModem*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_modem_capabilities"
              c:identifier="nm_device_modem_get_modem_capabilities">
        <doc xml:space="preserve">Returns a bitfield of the generic access technology families the modem
supports.  Not all capabilities are available concurrently however; some
may require a firmware reload or reinitialization.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the generic access technology families the modem supports</doc>
          <type name="NetworkManager.DeviceModemCapabilities"
                c:type="NMDeviceModemCapabilities"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceModem</doc>
            <type name="DeviceModem" c:type="NMDeviceModem*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="current-capabilities" transfer-ownership="none">
        <doc xml:space="preserve">The generic family of access technologies the modem currently supports
without a firmware reload or reinitialization.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="modem-capabilities" transfer-ownership="none">
        <doc xml:space="preserve">The generic family of access technologies the modem supports.  Not all
capabilities are available at the same time however; some modems require
a firmware reload or other reinitialization to switch between eg
CDMA/EVDO and GSM/UMTS.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceModemClass"
            c:type="NMDeviceModemClass"
            glib:is-gtype-struct-for="DeviceModem">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="DeviceModemError"
                 glib:type-name="NMDeviceModemError"
                 glib:get-type="nm_device_modem_error_get_type"
                 c:type="NMDeviceModemError"
                 glib:error-domain="nm-device-modem-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_DEVICE_MODEM_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="NotModemConnection"
              value="1"
              c:identifier="NM_DEVICE_MODEM_ERROR_NOT_MODEM_CONNECTION"
              glib:nick="NotModemConnection">
        <doc xml:space="preserve">the connection was not of modem type</doc>
      </member>
      <member name="InvalidModemConnection"
              value="2"
              c:identifier="NM_DEVICE_MODEM_ERROR_INVALID_MODEM_CONNECTION"
              glib:nick="InvalidModemConnection">
        <doc xml:space="preserve">the modem connection was invalid</doc>
      </member>
      <member name="MissingDeviceCaps"
              value="3"
              c:identifier="NM_DEVICE_MODEM_ERROR_MISSING_DEVICE_CAPS"
              glib:nick="MissingDeviceCaps">
        <doc xml:space="preserve">the device missed required capabilities</doc>
      </member>
      <function name="quark" c:identifier="nm_device_modem_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMDeviceModem if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMDeviceModem errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="DeviceOlpcMesh"
           c:symbol-prefix="device_olpc_mesh"
           c:type="NMDeviceOlpcMesh"
           parent="Device"
           glib:type-name="NMDeviceOlpcMesh"
           glib:get-type="nm_device_olpc_mesh_get_type"
           glib:type-struct="DeviceOlpcMeshClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_device_olpc_mesh_new">
        <doc xml:space="preserve">Creates a new #NMDeviceOlpcMesh.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new OlpcMesh device</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_active_channel"
              c:identifier="nm_device_olpc_mesh_get_active_channel">
        <doc xml:space="preserve">Returns the active channel of the #NMDeviceOlpcMesh device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">active channel of the device</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceOlpcMesh</doc>
            <type name="DeviceOlpcMesh" c:type="NMDeviceOlpcMesh*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_companion"
              c:identifier="nm_device_olpc_mesh_get_companion">
        <doc xml:space="preserve">Gets the companion device of the #NMDeviceOlpcMesh.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the companion of the device of %NULL</doc>
          <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceOlpcMesh</doc>
            <type name="DeviceOlpcMesh" c:type="NMDeviceOlpcMesh*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_olpc_mesh_get_hw_address">
        <doc xml:space="preserve">Gets the hardware (MAC) address of the #NMDeviceOlpcMesh</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceOlpcMesh</doc>
            <type name="DeviceOlpcMesh" c:type="NMDeviceOlpcMesh*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="active-channel" transfer-ownership="none">
        <doc xml:space="preserve">The device's active channel.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="companion" transfer-ownership="none">
        <doc xml:space="preserve">The companion device.</doc>
        <type name="DeviceWifi"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:space="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceOlpcMeshClass"
            c:type="NMDeviceOlpcMeshClass"
            glib:is-gtype-struct-for="DeviceOlpcMesh">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="DeviceOlpcMeshError"
                 glib:type-name="NMDeviceOlpcMeshError"
                 glib:get-type="nm_device_olpc_mesh_error_get_type"
                 c:type="NMDeviceOlpcMeshError"
                 glib:error-domain="nm-device-olpc-mesh-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_DEVICE_OLPC_MESH_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="NotOlpcMeshConnection"
              value="1"
              c:identifier="NM_DEVICE_OLPC_MESH_ERROR_NOT_OLPC_MESH_CONNECTION"
              glib:nick="NotOlpcMeshConnection">
        <doc xml:space="preserve">the connection was not of Olpc Mesh type</doc>
      </member>
      <member name="InvalidOlpcMeshConnection"
              value="2"
              c:identifier="NM_DEVICE_OLPC_MESH_ERROR_INVALID_OLPC_MESH_CONNECTION"
              glib:nick="InvalidOlpcMeshConnection">
        <doc xml:space="preserve">the Olpc Mesh connection was invalid</doc>
      </member>
      <function name="quark" c:identifier="nm_device_olpc_mesh_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMDeviceOlpcMesh if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMDeviceOlpcMesh errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="DeviceTeam"
           c:symbol-prefix="device_team"
           c:type="NMDeviceTeam"
           parent="Device"
           glib:type-name="NMDeviceTeam"
           glib:get-type="nm_device_team_get_type"
           glib:type-struct="DeviceTeamClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new"
                   c:identifier="nm_device_team_new"
                   version="0.9.10">
        <doc xml:space="preserve">Creates a new #NMDeviceTeam.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new device</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_carrier"
              c:identifier="nm_device_team_get_carrier"
              version="0.9.10">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the device has carrier</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceTeam</doc>
            <type name="DeviceTeam" c:type="NMDeviceTeam*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_team_get_hw_address"
              version="0.9.10">
        <doc xml:space="preserve">Gets the hardware (MAC) address of the #NMDeviceTeam</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceTeam</doc>
            <type name="DeviceTeam" c:type="NMDeviceTeam*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_slaves"
              c:identifier="nm_device_team_get_slaves"
              version="0.9.10">
        <doc xml:space="preserve">Gets the devices currently enslaved to @device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GPtrArray containing
#NMDevices that are slaves of @device. This is the internal
copy used by the device, and must not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="Device"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceTeam</doc>
            <type name="DeviceTeam" c:type="NMDeviceTeam*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="carrier" transfer-ownership="none">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:space="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="slaves" transfer-ownership="none">
        <doc xml:space="preserve">The devices (#NMDevice) enslaved to the team device.</doc>
        <type name="ObjectArray"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceTeamClass"
            c:type="NMDeviceTeamClass"
            glib:is-gtype-struct-for="DeviceTeam">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="DeviceTeamError"
                 glib:type-name="NMDeviceTeamError"
                 glib:get-type="nm_device_team_error_get_type"
                 c:type="NMDeviceTeamError"
                 glib:error-domain="nm-device-team-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_DEVICE_TEAM_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="NotTeamConnection"
              value="1"
              c:identifier="NM_DEVICE_TEAM_ERROR_NOT_TEAM_CONNECTION"
              glib:nick="NotTeamConnection">
        <doc xml:space="preserve">the connection was not of team type</doc>
      </member>
      <member name="InvalidTeamConnection"
              value="2"
              c:identifier="NM_DEVICE_TEAM_ERROR_INVALID_TEAM_CONNECTION"
              glib:nick="InvalidTeamConnection">
        <doc xml:space="preserve">the team connection was invalid</doc>
      </member>
      <member name="InterfaceMismatch"
              value="3"
              c:identifier="NM_DEVICE_TEAM_ERROR_INTERFACE_MISMATCH"
              glib:nick="InterfaceMismatch">
        <doc xml:space="preserve">the interfaces of the connection and the device mismatched</doc>
      </member>
      <function name="quark"
                c:identifier="nm_device_team_error_quark"
                version="0.9.10">
        <doc xml:space="preserve">Registers an error quark for #NMDeviceTeam if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMDeviceTeam errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="DeviceVlan"
           c:symbol-prefix="device_vlan"
           c:type="NMDeviceVlan"
           parent="Device"
           glib:type-name="NMDeviceVlan"
           glib:get-type="nm_device_vlan_get_type"
           glib:type-struct="DeviceVlanClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_device_vlan_new">
        <doc xml:space="preserve">Creates a new #NMDeviceVlan.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new device</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_carrier" c:identifier="nm_device_vlan_get_carrier">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the device has carrier</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceVlan</doc>
            <type name="DeviceVlan" c:type="NMDeviceVlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_vlan_get_hw_address">
        <doc xml:space="preserve">Gets the hardware (MAC) address of the #NMDeviceVlan</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceVlan</doc>
            <type name="DeviceVlan" c:type="NMDeviceVlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parent"
              c:identifier="nm_device_vlan_get_parent"
              version="1.0">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the device's parent device</doc>
          <type name="Device" c:type="NMDevice*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceVlan</doc>
            <type name="DeviceVlan" c:type="NMDeviceVlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vlan_id" c:identifier="nm_device_vlan_get_vlan_id">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the device's VLAN ID</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceVlan</doc>
            <type name="DeviceVlan" c:type="NMDeviceVlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="carrier" transfer-ownership="none">
        <doc xml:space="preserve">Whether the device has carrier.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:space="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="parent" version="1.0" transfer-ownership="none">
        <doc xml:space="preserve">The devices's parent device.</doc>
        <type name="Device"/>
      </property>
      <property name="vlan-id" transfer-ownership="none">
        <doc xml:space="preserve">The device's VLAN ID.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceVlanClass"
            c:type="NMDeviceVlanClass"
            glib:is-gtype-struct-for="DeviceVlan">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="DeviceVlanError"
                 glib:type-name="NMDeviceVlanError"
                 glib:get-type="nm_device_vlan_error_get_type"
                 c:type="NMDeviceVlanError"
                 glib:error-domain="nm-device-vlan-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_DEVICE_VLAN_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="NotVlanConnection"
              value="1"
              c:identifier="NM_DEVICE_VLAN_ERROR_NOT_VLAN_CONNECTION"
              glib:nick="NotVlanConnection">
        <doc xml:space="preserve">the connection was not of VLAN type</doc>
      </member>
      <member name="InvalidVlanConnection"
              value="2"
              c:identifier="NM_DEVICE_VLAN_ERROR_INVALID_VLAN_CONNECTION"
              glib:nick="InvalidVlanConnection">
        <doc xml:space="preserve">the VLAN connection was invalid</doc>
      </member>
      <member name="IdMismatch"
              value="3"
              c:identifier="NM_DEVICE_VLAN_ERROR_ID_MISMATCH"
              glib:nick="IdMismatch">
        <doc xml:space="preserve">the VLAN identifiers of the connection and the device mismatched</doc>
      </member>
      <member name="InterfaceMismatch"
              value="4"
              c:identifier="NM_DEVICE_VLAN_ERROR_INTERFACE_MISMATCH"
              glib:nick="InterfaceMismatch">
        <doc xml:space="preserve">the interfaces of the connection and the device mismatched</doc>
      </member>
      <member name="MacMismatch"
              value="5"
              c:identifier="NM_DEVICE_VLAN_ERROR_MAC_MISMATCH"
              glib:nick="MacMismatch">
        <doc xml:space="preserve">the MACs of the connection and the device mismatched</doc>
      </member>
      <function name="quark" c:identifier="nm_device_vlan_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMDeviceVlan if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMDeviceVlan errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="DeviceWifi"
           c:symbol-prefix="device_wifi"
           c:type="NMDeviceWifi"
           parent="Device"
           glib:type-name="NMDeviceWifi"
           glib:get-type="nm_device_wifi_get_type"
           glib:type-struct="DeviceWifiClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_device_wifi_new">
        <doc xml:space="preserve">Creates a new #NMDeviceWifi.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new Wi-Fi device</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="access_point_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
          <parameter name="ap" transfer-ownership="none">
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="access_point_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
          <parameter name="ap" transfer-ownership="none">
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_access_point_by_path"
              c:identifier="nm_device_wifi_get_access_point_by_path">
        <doc xml:space="preserve">Gets a #NMAccessPoint by path.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the access point or %NULL if none is found.</doc>
          <type name="AccessPoint" c:type="NMAccessPoint*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the object path of the access point</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_access_points"
              c:identifier="nm_device_wifi_get_access_points">
        <doc xml:space="preserve">Gets all the scanned access points of the #NMDeviceWifi.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GPtrArray containing all the
scanned #NMAccessPoints.
The returned array is owned by the client and should not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="AccessPoint"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_active_access_point"
              c:identifier="nm_device_wifi_get_active_access_point">
        <doc xml:space="preserve">Gets the active #NMAccessPoint.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the access point or %NULL if none is active</doc>
          <type name="AccessPoint" c:type="NMAccessPoint*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bitrate" c:identifier="nm_device_wifi_get_bitrate">
        <doc xml:space="preserve">Gets the bit rate of the #NMDeviceWifi in kbit/s.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the bit rate (kbit/s)</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_capabilities"
              c:identifier="nm_device_wifi_get_capabilities">
        <doc xml:space="preserve">Gets the Wi-Fi capabilities of the #NMDeviceWifi.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the capabilities</doc>
          <type name="NetworkManager.DeviceWifiCapabilities"
                c:type="NMDeviceWifiCapabilities"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_wifi_get_hw_address">
        <doc xml:space="preserve">Gets the actual hardware (MAC) address of the #NMDeviceWifi</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the actual hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mode" c:identifier="nm_device_wifi_get_mode">
        <doc xml:space="preserve">Gets the #NMDeviceWifi mode.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the mode</doc>
          <type name="NetworkManager.80211Mode" c:type="NM80211Mode"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_permanent_hw_address"
              c:identifier="nm_device_wifi_get_permanent_hw_address">
        <doc xml:space="preserve">Gets the permanent hardware (MAC) address of the #NMDeviceWifi</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the permanent hardware address. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="request_scan_simple"
              c:identifier="nm_device_wifi_request_scan_simple"
              version="0.9.8">
        <doc xml:space="preserve">Request NM to scan for access points on the #NMDeviceWifi. This function only
instructs NM to perform scanning. Use nm_device_wifi_get_access_points()
to get available access points.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">the function to call when the call is done</doc>
            <type name="DeviceWifiRequestScanFn"
                  c:type="NMDeviceWifiRequestScanFn"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">user data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <property name="access-points"
                version="0.9.10"
                transfer-ownership="none">
        <doc xml:space="preserve">List of all Wi-Fi access points the device can see.</doc>
        <type name="ObjectArray"/>
      </property>
      <property name="active-access-point" transfer-ownership="none">
        <doc xml:space="preserve">The active #NMAccessPoint of the device.</doc>
        <type name="AccessPoint"/>
      </property>
      <property name="bitrate" transfer-ownership="none">
        <doc xml:space="preserve">The bit rate of the device in kbit/s.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:space="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="mode" transfer-ownership="none">
        <doc xml:space="preserve">The mode of the device.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="perm-hw-address" transfer-ownership="none">
        <doc xml:space="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="wireless-capabilities" transfer-ownership="none">
        <doc xml:space="preserve">The wireless capabilities of the device.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
      <glib:signal name="access-point-added" when="first">
        <doc xml:space="preserve">Notifies that a #NMAccessPoint is added to the Wi-Fi device.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">the new access point</doc>
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="access-point-removed" when="first">
        <doc xml:space="preserve">Notifies that a #NMAccessPoint is removed from the Wi-Fi device.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="ap" transfer-ownership="none">
            <doc xml:space="preserve">the removed access point</doc>
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="DeviceWifiClass"
            c:type="NMDeviceWifiClass"
            glib:is-gtype-struct-for="DeviceWifi">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="access_point_added">
        <callback name="access_point_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="device" transfer-ownership="none">
              <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
            </parameter>
            <parameter name="ap" transfer-ownership="none">
              <type name="AccessPoint" c:type="NMAccessPoint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="access_point_removed">
        <callback name="access_point_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="device" transfer-ownership="none">
              <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
            </parameter>
            <parameter name="ap" transfer-ownership="none">
              <type name="AccessPoint" c:type="NMAccessPoint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="DeviceWifiError"
                 glib:type-name="NMDeviceWifiError"
                 glib:get-type="nm_device_wifi_error_get_type"
                 c:type="NMDeviceWifiError"
                 glib:error-domain="nm-device-wifi-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_DEVICE_WIFI_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="NotWifiConnection"
              value="1"
              c:identifier="NM_DEVICE_WIFI_ERROR_NOT_WIFI_CONNECTION"
              glib:nick="NotWifiConnection">
        <doc xml:space="preserve">the connection was not of Wi-Fi type</doc>
      </member>
      <member name="InvalidWifiConnection"
              value="2"
              c:identifier="NM_DEVICE_WIFI_ERROR_INVALID_WIFI_CONNECTION"
              glib:nick="InvalidWifiConnection">
        <doc xml:space="preserve">the Wi-Fi connection was invalid</doc>
      </member>
      <member name="InvalidDeviceMac"
              value="3"
              c:identifier="NM_DEVICE_WIFI_ERROR_INVALID_DEVICE_MAC"
              glib:nick="InvalidDeviceMac">
        <doc xml:space="preserve">the device's MAC was invalid</doc>
      </member>
      <member name="MacMismatch"
              value="4"
              c:identifier="NM_DEVICE_WIFI_ERROR_MAC_MISMATCH"
              glib:nick="MacMismatch">
        <doc xml:space="preserve">the MACs of the connection and the device mismatched</doc>
      </member>
      <member name="MissingDeviceWpaCaps"
              value="5"
              c:identifier="NM_DEVICE_WIFI_ERROR_MISSING_DEVICE_WPA_CAPS"
              glib:nick="MissingDeviceWpaCaps">
        <doc xml:space="preserve">the device missed WPA capabilities
required by the connection</doc>
      </member>
      <member name="MissingDeviceRsnCaps"
              value="6"
              c:identifier="NM_DEVICE_WIFI_ERROR_MISSING_DEVICE_RSN_CAPS"
              glib:nick="MissingDeviceRsnCaps">
        <doc xml:space="preserve">the device missed RSN capabilities
required by the connection</doc>
      </member>
      <function name="quark" c:identifier="nm_device_wifi_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMDeviceWifi if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMDeviceWifi errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <callback name="DeviceWifiRequestScanFn"
              c:type="NMDeviceWifiRequestScanFn">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="device" transfer-ownership="none">
          <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="DeviceWimax"
           c:symbol-prefix="device_wimax"
           c:type="NMDeviceWimax"
           parent="Device"
           glib:type-name="NMDeviceWimax"
           glib:get-type="nm_device_wimax_get_type"
           glib:type-struct="DeviceWimaxClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_device_wimax_new">
        <doc xml:space="preserve">Creates a new #NMDeviceWimax.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new WiMAX device</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the D-Bus object path of the WiMAX device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="nsp_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
          <parameter name="nsp" transfer-ownership="none">
            <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="nsp_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
          <parameter name="nsp" transfer-ownership="none">
            <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_active_nsp"
              c:identifier="nm_device_wimax_get_active_nsp">
        <doc xml:space="preserve">Gets the active #NMWimaxNsp.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the access point or %NULL if none is active</doc>
          <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
        </return-value>
        <parameters>
          <instance-parameter name="wimax" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bsid" c:identifier="nm_device_wimax_get_bsid">
        <doc xml:space="preserve">Gets the ID of the serving Base Station when the device is connected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the ID of the serving Base Station, or %NULL</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_center_frequency"
              c:identifier="nm_device_wimax_get_center_frequency">
        <doc xml:space="preserve">Gets the center frequency (in KHz) of the radio channel the device is using
to communicate with the network when connected.  Has no meaning when the
device is not connected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the center frequency in KHz, or 0</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_cinr" c:identifier="nm_device_wimax_get_cinr">
        <doc xml:space="preserve">Gets the CINR (Carrier to Interference + Noise Ratio) of the current radio
link in dB.  CINR is a more accurate measure of radio link quality.  Has no
meaning when the device is not connected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the CINR in dB, or 0</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_wimax_get_hw_address">
        <doc xml:space="preserve">Gets the hardware (MAC) address of the #NMDeviceWimax</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the hardware address. This is the internal string used by the
         device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="wimax" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_nsp_by_path"
              c:identifier="nm_device_wimax_get_nsp_by_path">
        <doc xml:space="preserve">Gets a #NMWimaxNsp by path.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the access point or %NULL if none is found.</doc>
          <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
        </return-value>
        <parameters>
          <instance-parameter name="wimax" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the object path of the NSP</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_nsps" c:identifier="nm_device_wimax_get_nsps">
        <doc xml:space="preserve">Gets all the scanned NSPs of the #NMDeviceWimax.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GPtrArray containing
         all the scanned #NMWimaxNsps.
The returned array is owned by the client and should not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="WimaxNsp"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="wimax" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_rssi" c:identifier="nm_device_wimax_get_rssi">
        <doc xml:space="preserve">Gets the RSSI of the current radio link in dBm.  This value indicates how
strong the raw received RF signal from the base station is, but does not
indicate the overall quality of the radio link.  Has no meaning when the
device is not connected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the RSSI in dBm, or 0</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tx_power" c:identifier="nm_device_wimax_get_tx_power">
        <doc xml:space="preserve">Average power of the last burst transmitted by the device, in units of
0.5 dBm.  i.e. a TxPower of -11 represents an actual device TX power of
-5.5 dBm.  Has no meaning when the device is not connected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the TX power in dBm, or 0</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="active-nsp" transfer-ownership="none">
        <doc xml:space="preserve">The active #NMWimaxNsp of the device.</doc>
        <type name="WimaxNsp"/>
      </property>
      <property name="bsid" transfer-ownership="none">
        <doc xml:space="preserve">The ID of the serving base station as received from the network.  Has
no meaning when the device is not connected.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="center-frequency" transfer-ownership="none">
        <doc xml:space="preserve">The center frequency (in KHz) of the radio channel the device is using to
communicate with the network when connected.  Has no meaning when the
device is not connected.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="cinr" transfer-ownership="none">
        <doc xml:space="preserve">CINR (Carrier to Interference + Noise Ratio) of the current radio link
in dB.  CINR is a more accurate measure of radio link quality.  Has no
meaning when the device is not connected.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:space="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="nsps" version="0.9.10" transfer-ownership="none">
        <doc xml:space="preserve">List of all WiMAX Network Service Providers the device can see.</doc>
        <type name="ObjectArray"/>
      </property>
      <property name="rssi" transfer-ownership="none">
        <doc xml:space="preserve">RSSI of the current radio link in dBm.  This value indicates how strong
the raw received RF signal from the base station is, but does not
indicate the overall quality of the radio link.  Has no meaning when the
device is not connected.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="tx-power" transfer-ownership="none">
        <doc xml:space="preserve">Average power of the last burst transmitted by the device, in units of
0.5 dBm.  i.e. a TxPower of -11 represents an actual device TX power of
-5.5 dBm.  Has no meaning when the device is not connected.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
      <glib:signal name="nsp-added" when="first">
        <doc xml:space="preserve">Notifies that a #NMWimaxNsp is added to the wimax device.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="nsp" transfer-ownership="none">
            <doc xml:space="preserve">the new NSP</doc>
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="nsp-removed" when="first">
        <doc xml:space="preserve">Notifies that a #NMWimaxNsp is removed from the wimax device.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="nsp" transfer-ownership="none">
            <doc xml:space="preserve">the removed NSP</doc>
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="DeviceWimaxClass"
            c:type="NMDeviceWimaxClass"
            glib:is-gtype-struct-for="DeviceWimax">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="nsp_added">
        <callback name="nsp_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
            </parameter>
            <parameter name="nsp" transfer-ownership="none">
              <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="nsp_removed">
        <callback name="nsp_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
            </parameter>
            <parameter name="nsp" transfer-ownership="none">
              <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="DeviceWimaxError"
                 glib:type-name="NMDeviceWimaxError"
                 glib:get-type="nm_device_wimax_error_get_type"
                 c:type="NMDeviceWimaxError"
                 glib:error-domain="nm-device-wimax-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_DEVICE_WIMAX_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="NotWimaxConnection"
              value="1"
              c:identifier="NM_DEVICE_WIMAX_ERROR_NOT_WIMAX_CONNECTION"
              glib:nick="NotWimaxConnection">
        <doc xml:space="preserve">the connection was not of WiMax type</doc>
      </member>
      <member name="InvalidWimaxConnection"
              value="2"
              c:identifier="NM_DEVICE_WIMAX_ERROR_INVALID_WIMAX_CONNECTION"
              glib:nick="InvalidWimaxConnection">
        <doc xml:space="preserve">the WiMax connection was invalid</doc>
      </member>
      <member name="InvalidDeviceMac"
              value="3"
              c:identifier="NM_DEVICE_WIMAX_ERROR_INVALID_DEVICE_MAC"
              glib:nick="InvalidDeviceMac">
        <doc xml:space="preserve">the device's MAC was invalid</doc>
      </member>
      <member name="MacMismatch"
              value="4"
              c:identifier="NM_DEVICE_WIMAX_ERROR_MAC_MISMATCH"
              glib:nick="MacMismatch">
        <doc xml:space="preserve">the MACs of the connection and the device mismatched</doc>
      </member>
      <function name="quark" c:identifier="nm_device_wimax_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMDeviceWimax if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMDeviceWimax errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="IP4Config"
           c:symbol-prefix="ip4_config"
           c:type="NMIP4Config"
           parent="Object"
           glib:type-name="NMIP4Config"
           glib:get-type="nm_ip4_config_get_type"
           glib:type-struct="IP4ConfigClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_ip4_config_new">
        <doc xml:space="preserve">Creates a new #NMIP4Config.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new IP4 configuration</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_addresses" c:identifier="nm_ip4_config_get_addresses">
        <doc xml:space="preserve">Gets the IP4 addresses (containing the address, prefix, and gateway).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GSList containing #NMIP4Address&lt;!-- --&gt;es.
This is the internal copy used by the configuration and must not be modified.</doc>
          <type name="GLib.SList" c:type="const GSList*">
            <type name="NetworkManager.IP4Address"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMIP4Config</doc>
            <type name="IP4Config" c:type="NMIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_domains" c:identifier="nm_ip4_config_get_domains">
        <doc xml:space="preserve">Gets the domain names.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GPtrArray containing domains as strings. This is the
internal copy used by the configuration, and must not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMIP4Config</doc>
            <type name="IP4Config" c:type="NMIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_gateway"
              c:identifier="nm_ip4_config_get_gateway"
              version="0.9.10">
        <doc xml:space="preserve">Gets the IP4 gateway address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IP4 address of the gateway.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMIP4Config</doc>
            <type name="IP4Config" c:type="NMIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_nameservers"
              c:identifier="nm_ip4_config_get_nameservers">
        <doc xml:space="preserve">Gets the domain name servers (DNS).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GArray containing #guint32s.
This is the internal copy used by the configuration and must not be
modified.</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="guint32"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMIP4Config</doc>
            <type name="IP4Config" c:type="NMIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_routes" c:identifier="nm_ip4_config_get_routes">
        <doc xml:space="preserve">Gets the routes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GSList containing
#NMIP4Routes. This is the internal copy used by the configuration,
and must not be modified.</doc>
          <type name="GLib.SList" c:type="const GSList*">
            <type name="NetworkManager.IP4Route"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMIP4Config</doc>
            <type name="IP4Config" c:type="NMIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_searches"
              c:identifier="nm_ip4_config_get_searches"
              version="0.9.10">
        <doc xml:space="preserve">Gets the dns searches.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GPtrArray containing dns searches as strings. This is the
internal copy used by the configuration, and must not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMIP4Config</doc>
            <type name="IP4Config" c:type="NMIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_wins_servers"
              c:identifier="nm_ip4_config_get_wins_servers">
        <doc xml:space="preserve">Gets the Windows Internet Name Service servers (WINS).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GArray containing #guint32s.
This is the internal copy used by the configuration and must not be
modified.</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="guint32"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMIP4Config</doc>
            <type name="IP4Config" c:type="NMIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="addresses" transfer-ownership="none">
        <doc xml:space="preserve">The #GPtrArray containing #NMIP4Address&lt;!-- --&gt;es of the configuration.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="domains" transfer-ownership="none">
        <doc xml:space="preserve">The #GPtrArray containing domain strings of the configuration.</doc>
        <type name="StringArray"/>
      </property>
      <property name="gateway" version="0.9.10" transfer-ownership="none">
        <doc xml:space="preserve">The IP4 gateway address of the configuration as string.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="nameservers" transfer-ownership="none">
        <doc xml:space="preserve">The #GArray containing name servers (#guint32s) of the configuration.</doc>
        <type name="UintArray"/>
      </property>
      <property name="routes" transfer-ownership="none">
        <doc xml:space="preserve">The #GPtrArray containing #NMSettingIP4Routes of the configuration.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="searches" version="0.9.10" transfer-ownership="none">
        <doc xml:space="preserve">The #GPtrArray containing dns search strings of the configuration.</doc>
        <type name="StringArray"/>
      </property>
      <property name="wins-servers" transfer-ownership="none">
        <doc xml:space="preserve">The #GArray containing WINS servers (#guint32s) of the configuration.</doc>
        <type name="UintArray"/>
      </property>
      <field name="parent">
        <type name="Object" c:type="NMObject"/>
      </field>
    </class>
    <record name="IP4ConfigClass"
            c:type="NMIP4ConfigClass"
            glib:is-gtype-struct-for="IP4Config">
      <field name="parent">
        <type name="ObjectClass" c:type="NMObjectClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <constant name="IP4_CONFIG_ADDRESSES"
              value="addresses"
              c:type="NM_IP4_CONFIG_ADDRESSES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP4_CONFIG_DOMAINS"
              value="domains"
              c:type="NM_IP4_CONFIG_DOMAINS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP4_CONFIG_GATEWAY"
              value="gateway"
              c:type="NM_IP4_CONFIG_GATEWAY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP4_CONFIG_NAMESERVERS"
              value="nameservers"
              c:type="NM_IP4_CONFIG_NAMESERVERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP4_CONFIG_ROUTES"
              value="routes"
              c:type="NM_IP4_CONFIG_ROUTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP4_CONFIG_SEARCHES"
              value="searches"
              c:type="NM_IP4_CONFIG_SEARCHES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP4_CONFIG_WINS_SERVERS"
              value="wins-servers"
              c:type="NM_IP4_CONFIG_WINS_SERVERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <glib:boxed glib:name="IP6AddressArray"
                c:symbol-prefix="ip6_address_array"
                glib:type-name="NMIP6AddressArray"
                glib:get-type="nm_ip6_address_array_get_type">
    </glib:boxed>
    <glib:boxed glib:name="IP6AddressObjectArray"
                c:symbol-prefix="ip6_address_object_array"
                glib:type-name="NMIP6AddressObjectArray"
                glib:get-type="nm_ip6_address_object_array_get_type">
    </glib:boxed>
    <class name="IP6Config"
           c:symbol-prefix="ip6_config"
           c:type="NMIP6Config"
           parent="Object"
           glib:type-name="NMIP6Config"
           glib:get-type="nm_ip6_config_get_type"
           glib:type-struct="IP6ConfigClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_ip6_config_new">
        <doc xml:space="preserve">Creates a new #NMIP6Config.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new IP6 configuration</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:space="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_addresses" c:identifier="nm_ip6_config_get_addresses">
        <doc xml:space="preserve">Gets the IP6 addresses (containing the address, prefix, and gateway).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GSList containing
#NMIP6Address&lt;!-- --&gt;es. This is the internal copy used by the configuration
and must not be modified.</doc>
          <type name="GLib.SList" c:type="const GSList*">
            <type name="NetworkManager.IP6Address"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMIP6Config</doc>
            <type name="IP6Config" c:type="NMIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_domains" c:identifier="nm_ip6_config_get_domains">
        <doc xml:space="preserve">Gets the domain names.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GPtrArray containing domains as strings.
This is the internal copy used by the configuration, and must not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMIP6Config</doc>
            <type name="IP6Config" c:type="NMIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_gateway"
              c:identifier="nm_ip6_config_get_gateway"
              version="0.9.10">
        <doc xml:space="preserve">Gets the IP6 gateway.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IPv6 gateway of the configuration.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMIP6Config</doc>
            <type name="IP6Config" c:type="NMIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_nameserver"
              c:identifier="nm_ip6_config_get_nameserver"
              version="0.9.10">
        <doc xml:space="preserve">Gets the domain name server at index @idx in the configuration.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">
         the IPv6 address of domain name server at index @iidx</doc>
          <array zero-terminated="0" c:type="gpointer*" fixed-size="16">
            <type name="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMIP6Config</doc>
            <type name="IP6Config" c:type="NMIP6Config*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the nameserver to return</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_nameservers"
              c:identifier="nm_ip6_config_get_nameservers"
              introspectable="0">
        <doc xml:space="preserve">Gets the domain name servers (DNS).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GSList containing elements of type 'struct in6_addr' which
contain the addresses of nameservers of the configuration.  This is the
internal copy used by the configuration and must not be modified.</doc>
          <type name="GLib.SList" c:type="const GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMIP6Config</doc>
            <type name="IP6Config" c:type="NMIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_nameservers"
              c:identifier="nm_ip6_config_get_num_nameservers"
              version="0.9.10">
        <doc xml:space="preserve">Gets the number of the domain name servers in the configuration.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of domain name servers</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMIP6Config</doc>
            <type name="IP6Config" c:type="NMIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_routes" c:identifier="nm_ip6_config_get_routes">
        <doc xml:space="preserve">Gets the routes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GSList containing
#NMIP6Routes. This is the internal copy used by the configuration,
and must not be modified.</doc>
          <type name="GLib.SList" c:type="const GSList*">
            <type name="NetworkManager.IP6Route"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMIP6Config</doc>
            <type name="IP6Config" c:type="NMIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_searches"
              c:identifier="nm_ip6_config_get_searches"
              version="0.9.10">
        <doc xml:space="preserve">Gets the dns searches.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GPtrArray containing dns searches as strings.
This is the internal copy used by the configuration, and must not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:space="preserve">a #NMIP6Config</doc>
            <type name="IP6Config" c:type="NMIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="addresses" transfer-ownership="none">
        <doc xml:space="preserve">The #GPtrArray containing the IPv6 addresses;  use
nm_utils_ip6_addresses_from_gvalue() to return a #GSList of
#NMSettingIP6Address objects that is more usable than the raw data.</doc>
        <type name="IP6AddressObjectArray"/>
      </property>
      <property name="domains" transfer-ownership="none">
        <doc xml:space="preserve">The #GPtrArray containing domain strings of the configuration.</doc>
        <type name="StringArray"/>
      </property>
      <property name="gateway" version="0.9.10" transfer-ownership="none">
        <doc xml:space="preserve">The IPv6 gateway as string</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="nameservers" transfer-ownership="none">
        <doc xml:space="preserve">The #GPtrArray containing elements of type 'struct ip6_addr' which
contain the addresses of nameservers of the configuration.</doc>
        <type name="IP6AddressArray"/>
      </property>
      <property name="routes" transfer-ownership="none">
        <doc xml:space="preserve">The #GPtrArray containing the IPv6 routes;  use
nm_utils_ip6_routes_from_gvalue() to return a #GSList of
#NMSettingIP6Address objects that is more usable than the raw data.</doc>
        <type name="IP6RouteObjectArray"/>
      </property>
      <property name="searches" version="0.9.10" transfer-ownership="none">
        <doc xml:space="preserve">The #GPtrArray containing dns search strings of the configuration.</doc>
        <type name="StringArray"/>
      </property>
      <field name="parent">
        <type name="Object" c:type="NMObject"/>
      </field>
    </class>
    <record name="IP6ConfigClass"
            c:type="NMIP6ConfigClass"
            glib:is-gtype-struct-for="IP6Config">
      <field name="parent">
        <type name="ObjectClass" c:type="NMObjectClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <glib:boxed glib:name="IP6RouteObjectArray"
                c:symbol-prefix="ip6_route_object_array"
                glib:type-name="NMIP6RouteObjectArray"
                glib:get-type="nm_ip6_route_object_array_get_type">
    </glib:boxed>
    <constant name="IP6_CONFIG_ADDRESSES"
              value="addresses"
              c:type="NM_IP6_CONFIG_ADDRESSES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP6_CONFIG_DOMAINS"
              value="domains"
              c:type="NM_IP6_CONFIG_DOMAINS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP6_CONFIG_GATEWAY"
              value="gateway"
              c:type="NM_IP6_CONFIG_GATEWAY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP6_CONFIG_NAMESERVERS"
              value="nameservers"
              c:type="NM_IP6_CONFIG_NAMESERVERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP6_CONFIG_ROUTES"
              value="routes"
              c:type="NM_IP6_CONFIG_ROUTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP6_CONFIG_SEARCHES"
              value="searches"
              c:type="NM_IP6_CONFIG_SEARCHES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="OBJECT_DBUS_CONNECTION"
              value="dbus-connection"
              c:type="NM_OBJECT_DBUS_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="OBJECT_DBUS_PATH"
              value="dbus-path"
              c:type="NM_OBJECT_DBUS_PATH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="Object"
           c:symbol-prefix="object"
           c:type="NMObject"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="NMObject"
           glib:get-type="nm_object_get_type"
           glib:type-struct="ObjectClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <virtual-method name="object_creation_failed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="master_object" transfer-ownership="none">
            <type name="Object" c:type="NMObject*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
          <parameter name="failed_path" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_connection" c:identifier="nm_object_get_connection">
        <doc xml:space="preserve">Gets the #NMObject's DBusGConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the connection</doc>
          <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #NMObject</doc>
            <type name="Object" c:type="NMObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_path" c:identifier="nm_object_get_path">
        <doc xml:space="preserve">Gets the DBus path of the #NMObject.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the object's path. This is the internal string used by the
device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #NMObject</doc>
            <type name="Object" c:type="NMObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="dbus-connection"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="dbus-path"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="object-creation-failed" when="first">
        <doc xml:space="preserve">Indicates that an error occured while creating an #NMObject object
during property handling of @master_object.

Note: Be aware that the signal is private for libnm-glib's internal
      use.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">the error that occured while creating object</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="failed_path" transfer-ownership="none">
            <doc xml:space="preserve">object path of the failed object</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <glib:boxed glib:name="ObjectArray"
                c:symbol-prefix="object_array"
                glib:type-name="NMObjectArray"
                glib:get-type="nm_object_array_get_type">
    </glib:boxed>
    <record name="ObjectClass"
            c:type="NMObjectClass"
            glib:is-gtype-struct-for="Object">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="object_creation_failed">
        <callback name="object_creation_failed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="master_object" transfer-ownership="none">
              <type name="Object" c:type="NMObject*"/>
            </parameter>
            <parameter name="error" transfer-ownership="none">
              <type name="GLib.Error" c:type="GError*"/>
            </parameter>
            <parameter name="failed_path" transfer-ownership="none">
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="ObjectError"
                 glib:type-name="NMObjectError"
                 glib:get-type="nm_object_error_get_type"
                 c:type="NMObjectError"
                 glib:error-domain="nm-object-error-quark">
      <doc xml:space="preserve">Describes errors that may result from operations involving a #NMObject.</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_OBJECT_ERROR_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="object_creation_failure"
              value="1"
              c:identifier="NM_OBJECT_ERROR_OBJECT_CREATION_FAILURE"
              glib:nick="object-creation-failure">
        <doc xml:space="preserve">an error ocured while creating an #NMObject</doc>
      </member>
      <function name="quark" c:identifier="nm_object_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMObject if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMObject errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <constant name="REMOTE_CONNECTION_REMOVED"
              value="removed"
              c:type="NM_REMOTE_CONNECTION_REMOVED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="REMOTE_CONNECTION_UNSAVED"
              value="unsaved"
              c:type="NM_REMOTE_CONNECTION_UNSAVED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="REMOTE_CONNECTION_UPDATED"
              value="updated"
              c:type="NM_REMOTE_CONNECTION_UPDATED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="REMOTE_SETTINGS_BUS"
              value="bus"
              c:type="NM_REMOTE_SETTINGS_BUS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="REMOTE_SETTINGS_CAN_MODIFY"
              value="can-modify"
              c:type="NM_REMOTE_SETTINGS_CAN_MODIFY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="REMOTE_SETTINGS_CONNECTIONS_READ"
              value="connections-read"
              c:type="NM_REMOTE_SETTINGS_CONNECTIONS_READ">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="REMOTE_SETTINGS_HOSTNAME"
              value="hostname"
              c:type="NM_REMOTE_SETTINGS_HOSTNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="REMOTE_SETTINGS_NEW_CONNECTION"
              value="new-connection"
              c:type="NM_REMOTE_SETTINGS_NEW_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="REMOTE_SETTINGS_SERVICE_RUNNING"
              value="service-running"
              c:type="NM_REMOTE_SETTINGS_SERVICE_RUNNING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="RemoteConnection"
           c:symbol-prefix="remote_connection"
           c:type="NMRemoteConnection"
           parent="NetworkManager.Connection"
           glib:type-name="NMRemoteConnection"
           glib:get-type="nm_remote_connection_get_type"
           glib:type-struct="RemoteConnectionClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_remote_connection_new">
        <doc xml:space="preserve">Creates a new object representing the remote connection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new remote connection object on success, or %NULL on failure</doc>
          <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
        </return-value>
        <parameters>
          <parameter name="bus" transfer-ownership="none">
            <doc xml:space="preserve">a valid and connected D-Bus connection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the D-Bus path of the connection as exported by the settings service</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="updated">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
          <parameter name="new_settings" transfer-ownership="none">
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="commit_changes"
              c:identifier="nm_remote_connection_commit_changes">
        <doc xml:space="preserve">Send any local changes to the settings and properties of this connection to
NetworkManager, which will immediately save them to disk.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMRemoteConnection</doc>
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a function to be called when the
commit completes</doc>
            <type name="RemoteConnectionResultFunc"
                  c:type="NMRemoteConnectionResultFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">caller-specific data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="commit_changes_unsaved"
              c:identifier="nm_remote_connection_commit_changes_unsaved"
              version="0.9.10">
        <doc xml:space="preserve">Send any local changes to the settings and properties of this connection to
NetworkManager.  The changes are not saved to disk until either
nm_remote_connection_save() or nm_remote_connection_commit_changes() is
called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMRemoteConnection</doc>
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a function to be called when the
commit completes</doc>
            <type name="RemoteConnectionResultFunc"
                  c:type="NMRemoteConnectionResultFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">caller-specific data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete" c:identifier="nm_remote_connection_delete">
        <doc xml:space="preserve">Delete the connection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMRemoteConnection</doc>
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a function to be called when the delete completes</doc>
            <type name="RemoteConnectionResultFunc"
                  c:type="NMRemoteConnectionResultFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">caller-specific data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_secrets"
              c:identifier="nm_remote_connection_get_secrets">
        <doc xml:space="preserve">Request the connection's secrets.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMRemoteConnection</doc>
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
          <parameter name="setting_name" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting object name to get secrets for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a function to be called when the update completes;
must not be %NULL</doc>
            <type name="RemoteConnectionGetSecretsFunc"
                  c:type="NMRemoteConnectionGetSecretsFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">caller-specific data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_unsaved"
              c:identifier="nm_remote_connection_get_unsaved"
              version="0.9.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the remote connection contains changes that have not
been saved to disk, %FALSE if the connection is the same as its on-disk
representation.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMRemoteConnection</doc>
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="save"
              c:identifier="nm_remote_connection_save"
              version="0.9.10">
        <doc xml:space="preserve">Saves the connection to disk if the connection has changes that have not yet
been written to disk, or if the connection has never been saved.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMRemoteConnection</doc>
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">a function to be called when the
save completes</doc>
            <type name="RemoteConnectionResultFunc"
                  c:type="NMRemoteConnectionResultFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">caller-specific data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <property name="bus"
                introspectable="0"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #DBusGConnection that the #NMRemoteConnection is connected to.</doc>
        <type/>
      </property>
      <property name="dbus-connection"
                introspectable="0"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="dbus-path"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="unsaved" version="0.9.10" transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the remote connection contains changes that have not been saved
to disk, %FALSE if the connection is the same as its on-disk representation.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="NetworkManager.Connection" c:type="NMConnection"/>
      </field>
      <glib:signal name="removed" when="first">
        <doc xml:space="preserve">This signal is emitted when a connection is either deleted or becomes
invisible to the current user.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="updated" when="first">
        <doc xml:space="preserve">This signal is emitted when a connection changes, and it is
still visible to the user.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="visible" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="RemoteConnectionClass"
            c:type="NMRemoteConnectionClass"
            glib:is-gtype-struct-for="RemoteConnection">
      <field name="parent_class">
        <type name="NetworkManager.ConnectionClass"
              c:type="NMConnectionClass"/>
      </field>
      <field name="updated">
        <callback name="updated">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="connection" transfer-ownership="none">
              <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
            </parameter>
            <parameter name="new_settings" transfer-ownership="none">
              <type name="GLib.HashTable" c:type="GHashTable*">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="removed">
        <callback name="removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="connection" transfer-ownership="none">
              <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="RemoteConnectionError"
                 glib:type-name="NMRemoteConnectionError"
                 glib:get-type="nm_remote_connection_error_get_type"
                 c:type="NMRemoteConnectionError"
                 glib:error-domain="nm-remote-connection-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_REMOTE_CONNECTION_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="Disconnected"
              value="1"
              c:identifier="NM_REMOTE_CONNECTION_ERROR_DISCONNECTED"
              glib:nick="Disconnected">
        <doc xml:space="preserve">dbus disconnected</doc>
      </member>
      <function name="quark" c:identifier="nm_remote_connection_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMRemoteConnection if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMRemoteConnection errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <callback name="RemoteConnectionGetSecretsFunc"
              c:type="NMRemoteConnectionGetSecretsFunc">
      <doc xml:space="preserve">Called when NetworkManager returns secrets in response to a request for
secrets via nm_remote_connection_get_secrets().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">the connection for which secrets were requested</doc>
          <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
        </parameter>
        <parameter name="secrets" transfer-ownership="none">
          <doc xml:space="preserve">on success, a hash table of
 hash tables, with each inner hash mapping a setting property to a #GValue
 containing that property's value</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GLib.HashTable">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </type>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">on failure, a descriptive error</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:space="preserve">user data passed to nm_remote_connection_get_secrets()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="RemoteConnectionResultFunc"
              c:type="NMRemoteConnectionResultFunc">
      <doc xml:space="preserve">Called when NetworkManager has finished an asynchronous operation on a
connection, like commit changes, deleting, saving, etc.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">the connection for which an operation was performed</doc>
          <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">on failure, a descriptive error</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">user data passed to function which began the operation</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="RemoteSettings"
           c:symbol-prefix="remote_settings"
           c:type="NMRemoteSettings"
           parent="GObject.Object"
           glib:type-name="NMRemoteSettings"
           glib:get-type="nm_remote_settings_get_type"
           glib:type-struct="RemoteSettingsClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_remote_settings_new">
        <doc xml:space="preserve">Creates a new object representing the remote settings service.

Note that this will do blocking D-Bus calls to initialize the
settings object. You can use nm_remote_settings_new_async() if you
want to avoid that.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new remote settings object on success, or %NULL on failure</doc>
          <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
        </return-value>
        <parameters>
          <parameter name="bus"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a valid and connected D-Bus connection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_finish"
                   c:identifier="nm_remote_settings_new_finish"
                   throws="1">
        <doc xml:space="preserve">Gets the result of an nm_remote_settings_new_async() call.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #NMRemoteSettings object, or %NULL on error</doc>
          <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="new_async" c:identifier="nm_remote_settings_new_async">
        <doc xml:space="preserve">Creates a new object representing the remote settings service and
begins asynchronously initializing it. @callback will be called
when it is done; use nm_remote_settings_new_finish() to get the
result.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="bus"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a valid and connected D-Bus connection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">callback to call when the settings object is created</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="connections_read">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="new_connection">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_connection"
              c:identifier="nm_remote_settings_add_connection">
        <doc xml:space="preserve">Requests that the remote settings service add the given settings to a new
connection.  The connection is immediately written to disk.  @connection is
untouched by this function and only serves as a template of the settings to
add.  The #NMRemoteConnection object that represents what NetworkManager
actually added is returned to @callback when the addition operation is complete.

Note that the #NMRemoteConnection returned in @callback may not contain
identical settings to @connection as NetworkManager may perform automatic
completion and/or normalization of connection properties.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the request was successful, %FALSE if it failed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">the %NMRemoteSettings</doc>
            <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the connection to add. Note that this object's settings will be
  added, not the object itself</doc>
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">callback to be called when the add operation completes</doc>
            <type name="RemoteSettingsAddConnectionFunc"
                  c:type="NMRemoteSettingsAddConnectionFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">caller-specific data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_connection_unsaved"
              c:identifier="nm_remote_settings_add_connection_unsaved"
              version="0.9.10">
        <doc xml:space="preserve">Requests that the remote settings service add the given settings to a new
connection.  The connection is not written to disk, which may be done at
a later time by calling the connection's nm_remote_connection_commit_changes()
method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the request was successful, %FALSE if it failed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">the %NMRemoteSettings</doc>
            <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the connection to add. Note that this object's settings will be
  added, not the object itself</doc>
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">callback to be called when the add operation completes</doc>
            <type name="RemoteSettingsAddConnectionFunc"
                  c:type="NMRemoteSettingsAddConnectionFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">caller-specific data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_connection_by_id"
              c:identifier="nm_remote_settings_get_connection_by_id"
              version="0.9.10">
        <doc xml:space="preserve">Returns the first matching %NMRemoteConnection matching a given @id.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the remote connection object on success, or %NULL if no
 matching object was found.</doc>
          <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">the %NMRemoteSettings</doc>
            <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">the id of the remote connection</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_connection_by_path"
              c:identifier="nm_remote_settings_get_connection_by_path">
        <doc xml:space="preserve">Returns the %NMRemoteConnection representing the connection at @path.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the remote connection object on success, or %NULL if the object was
 not known</doc>
          <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">the %NMRemoteSettings</doc>
            <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the D-Bus object path of the remote connection</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_connection_by_uuid"
              c:identifier="nm_remote_settings_get_connection_by_uuid">
        <doc xml:space="preserve">Returns the %NMRemoteConnection identified by @uuid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the remote connection object on success, or %NULL if the object was
 not known</doc>
          <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">the %NMRemoteSettings</doc>
            <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
          </instance-parameter>
          <parameter name="uuid" transfer-ownership="none">
            <doc xml:space="preserve">the UUID of the remote connection</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_connections"
              c:identifier="nm_remote_settings_list_connections">
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a
list containing all connections provided by the remote settings service.
Each element of the returned list is a %NMRemoteConnection instance, which is
owned by the %NMRemoteSettings object and should not be freed by the caller.
The returned list is, however, owned by the caller and should be freed
using g_slist_free() when no longer required.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="RemoteConnection"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">the %NMRemoteSettings</doc>
            <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="load_connections"
              c:identifier="nm_remote_settings_load_connections"
              version="0.9.10"
              throws="1">
        <doc xml:space="preserve">Requests that the remote settings service load or reload the given files,
adding or updating the connections described within.

The changes to the indicated files will not yet be reflected in
@settings's connections array when the function returns.

If all of the indicated files were successfully loaded, the
function will return %TRUE, and @failures will be set to %NULL. If
NetworkManager tried to load the files, but some (or all) failed,
then @failures will be set to a %NULL-terminated array of the
filenames that failed to load.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if NetworkManager at least tried to load @filenames,
%FALSE if an error occurred (eg, permission denied).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">the %NMRemoteSettings</doc>
            <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
          </instance-parameter>
          <parameter name="filenames" transfer-ownership="none">
            <doc xml:space="preserve">%NULL-terminated array of filenames to load</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
          <parameter name="failures"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">on return, a %NULL-terminated array of
  filenames that failed to load</doc>
            <type name="utf8" c:type="char***"/>
          </parameter>
        </parameters>
      </method>
      <method name="reload_connections"
              c:identifier="nm_remote_settings_reload_connections"
              version="0.9.10"
              throws="1">
        <doc xml:space="preserve">Requests that the remote settings service reload all connection
files from disk, adding, updating, and removing connections until
the in-memory state matches the on-disk state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">the #NMRemoteSettings</doc>
            <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="save_hostname"
              c:identifier="nm_remote_settings_save_hostname">
        <doc xml:space="preserve">Requests that the machine's persistent hostname be set to the specified value
or cleared.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the request was successful, %FALSE if it failed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">the %NMRemoteSettings</doc>
            <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
          </instance-parameter>
          <parameter name="hostname" transfer-ownership="none">
            <doc xml:space="preserve">the new persistent hostname to set, or %NULL to clear any existing
 persistent hostname</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">callback to be called when the
hostname operation completes</doc>
            <type name="RemoteSettingsSaveHostnameFunc"
                  c:type="NMRemoteSettingsSaveHostnameFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">caller-specific data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <property name="bus"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #DBusGConnection that the #NMRemoteSettings is connected to. Defaults
to the system bus if not specified.</doc>
        <type/>
      </property>
      <property name="can-modify" transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, adding and modifying connections is supported.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="hostname" transfer-ownership="none">
        <doc xml:space="preserve">The machine hostname stored in persistent configuration. This can be
modified by calling nm_remote_settings_save_hostname().</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="service-running" transfer-ownership="none">
        <doc xml:space="preserve">Whether the settings service is running.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="connections-read" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="new-connection" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <callback name="RemoteSettingsAddConnectionFunc"
              c:type="NMRemoteSettingsAddConnectionFunc">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="settings" transfer-ownership="none">
          <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="RemoteSettingsClass"
            c:type="NMRemoteSettingsClass"
            glib:is-gtype-struct-for="RemoteSettings">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="new_connection">
        <callback name="new_connection">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="settings" transfer-ownership="none">
              <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="connections_read">
        <callback name="connections_read">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="settings" transfer-ownership="none">
              <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="RemoteSettingsError"
                 glib:type-name="NMRemoteSettingsError"
                 glib:get-type="nm_remote_settings_error_get_type"
                 c:type="NMRemoteSettingsError"
                 glib:error-domain="nm-remote-settings-error-quark">
      <doc xml:space="preserve">Describes errors that may result from operations involving a #NMRemoteSettings.</doc>
      <member name="UnknownError"
              value="0"
              c:identifier="NM_REMOTE_SETTINGS_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="ConnectionRemoved"
              value="1"
              c:identifier="NM_REMOTE_SETTINGS_ERROR_CONNECTION_REMOVED"
              glib:nick="ConnectionRemoved">
        <doc xml:space="preserve">the #NMRemoteConnection object
  was removed before it was completely initialized</doc>
      </member>
      <member name="ConnectionUnavailable"
              value="2"
              c:identifier="NM_REMOTE_SETTINGS_ERROR_CONNECTION_UNAVAILABLE"
              glib:nick="ConnectionUnavailable">
        <doc xml:space="preserve">the #NMRemoteConnection object
  is not visible or otherwise unreadable</doc>
      </member>
      <member name="ServiceUnavailable"
              value="3"
              c:identifier="NM_REMOTE_SETTINGS_ERROR_SERVICE_UNAVAILABLE"
              glib:nick="ServiceUnavailable">
        <doc xml:space="preserve">NetworkManager is not running.
  (Since 0.9.10)</doc>
      </member>
      <function name="quark" c:identifier="nm_remote_settings_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMRemoteSettings if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMRemoteSettings errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <callback name="RemoteSettingsLoadConnectionsFunc"
              c:type="NMRemoteSettingsLoadConnectionsFunc">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="settings" transfer-ownership="none">
          <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
        </parameter>
        <parameter name="failures" transfer-ownership="none">
          <type name="utf8" c:type="char**"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="RemoteSettingsSaveHostnameFunc"
              c:type="NMRemoteSettingsSaveHostnameFunc">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="settings" transfer-ownership="none">
          <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <constant name="SECRET_AGENT_AUTO_REGISTER"
              value="auto-register"
              c:type="NM_SECRET_AGENT_AUTO_REGISTER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SECRET_AGENT_CAPABILITIES"
              value="capabilities"
              c:type="NM_SECRET_AGENT_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SECRET_AGENT_IDENTIFIER"
              value="identifier"
              c:type="NM_SECRET_AGENT_IDENTIFIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SECRET_AGENT_REGISTERED"
              value="registered"
              c:type="NM_SECRET_AGENT_REGISTERED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SECRET_AGENT_REGISTRATION_RESULT"
              value="registration-result"
              c:type="NM_SECRET_AGENT_REGISTRATION_RESULT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="SecretAgent"
           c:symbol-prefix="secret_agent"
           c:type="NMSecretAgent"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="NMSecretAgent"
           glib:get-type="nm_secret_agent_get_type"
           glib:type-struct="SecretAgentClass">
      <virtual-method name="cancel_get_secrets">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="SecretAgent" c:type="NMSecretAgent*"/>
          </instance-parameter>
          <parameter name="connection_path" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="setting_name" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="delete_secrets" invoker="delete_secrets">
        <doc xml:space="preserve">Asynchronously ask the agent to delete all saved secrets belonging to
@connection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSecretAgent</doc>
            <type name="SecretAgent" c:type="NMSecretAgent*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection</doc>
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="connection_path" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback, to be invoked when the operation is done</doc>
            <type name="SecretAgentDeleteSecretsFunc"
                  c:type="NMSecretAgentDeleteSecretsFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:space="preserve">caller-specific data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_secrets" invoker="get_secrets">
        <doc xml:space="preserve">Asyncronously retrieve secrets belonging to @connection for the
setting @setting_name.  @flags indicate specific behavior that the secret
agent should use when performing the request, for example returning only
existing secrets without user interaction, or requesting entirely new
secrets from the user.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSecretAgent</doc>
            <type name="SecretAgent" c:type="NMSecretAgent*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection for which we're asked secrets</doc>
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="connection_path" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="setting_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the secret setting</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="hints" transfer-ownership="none">
            <doc xml:space="preserve">hints to the agent</doc>
            <array c:type="char**">
              <type name="utf8" c:type="char*"/>
            </array>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags that modify the behavior of the request</doc>
            <type name="SecretAgentGetSecretsFlags"
                  c:type="NMSecretAgentGetSecretsFlags"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="6">
            <doc xml:space="preserve">a callback, to be invoked when the operation is done</doc>
            <type name="SecretAgentGetSecretsFunc"
                  c:type="NMSecretAgentGetSecretsFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="6">
            <doc xml:space="preserve">caller-specific data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="registration_result">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <type name="SecretAgent" c:type="NMSecretAgent*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="save_secrets" invoker="save_secrets">
        <doc xml:space="preserve">Asyncronously ensure that all secrets inside @connection
are stored to disk.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSecretAgent</doc>
            <type name="SecretAgent" c:type="NMSecretAgent*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection</doc>
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="connection_path" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a callback, to be invoked when the operation is done</doc>
            <type name="SecretAgentSaveSecretsFunc"
                  c:type="NMSecretAgentSaveSecretsFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:space="preserve">caller-specific data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="delete_secrets"
              c:identifier="nm_secret_agent_delete_secrets">
        <doc xml:space="preserve">Asynchronously ask the agent to delete all saved secrets belonging to
@connection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSecretAgent</doc>
            <type name="SecretAgent" c:type="NMSecretAgent*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection</doc>
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback, to be invoked when the operation is done</doc>
            <type name="SecretAgentDeleteSecretsFunc"
                  c:type="NMSecretAgentDeleteSecretsFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">caller-specific data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_registered"
              c:identifier="nm_secret_agent_get_registered">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a %TRUE if the agent is registered, %FALSE if it is not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSecretAgent</doc>
            <type name="SecretAgent" c:type="NMSecretAgent*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_secrets" c:identifier="nm_secret_agent_get_secrets">
        <doc xml:space="preserve">Asyncronously retrieve secrets belonging to @connection for the
setting @setting_name.  @flags indicate specific behavior that the secret
agent should use when performing the request, for example returning only
existing secrets without user interaction, or requesting entirely new
secrets from the user.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSecretAgent</doc>
            <type name="SecretAgent" c:type="NMSecretAgent*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection for which we're asked secrets</doc>
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="setting_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the secret setting</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="hints" transfer-ownership="none">
            <doc xml:space="preserve">hints to the agent</doc>
            <array c:type="char**">
              <type name="utf8" c:type="char*"/>
            </array>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags that modify the behavior of the request</doc>
            <type name="SecretAgentGetSecretsFlags"
                  c:type="NMSecretAgentGetSecretsFlags"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="5">
            <doc xml:space="preserve">a callback, to be invoked when the operation is done</doc>
            <type name="SecretAgentGetSecretsFunc"
                  c:type="NMSecretAgentGetSecretsFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">caller-specific data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="register" c:identifier="nm_secret_agent_register">
        <doc xml:space="preserve">Registers the #NMSecretAgent with the NetworkManager secret manager,
indicating to NetworkManager that the agent is able to provide and save
secrets for connections on behalf of its user.  Registration is an
asynchronous operation and its success or failure is indicated via the
'registration-result' signal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a new %TRUE if registration was successfully requested (this does
not mean registration itself was successful), %FALSE if registration was not
successfully requested.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSecretAgent</doc>
            <type name="SecretAgent" c:type="NMSecretAgent*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="save_secrets" c:identifier="nm_secret_agent_save_secrets">
        <doc xml:space="preserve">Asyncronously ensure that all secrets inside @connection
are stored to disk.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSecretAgent</doc>
            <type name="SecretAgent" c:type="NMSecretAgent*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection</doc>
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a callback, to be invoked when the operation is done</doc>
            <type name="SecretAgentSaveSecretsFunc"
                  c:type="NMSecretAgentSaveSecretsFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">caller-specific data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unregister" c:identifier="nm_secret_agent_unregister">
        <doc xml:space="preserve">Unregisters the #NMSecretAgent with the NetworkManager secret manager,
indicating to NetworkManager that the agent is will no longer provide or
store secrets on behalf of this user.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a new %TRUE if unregistration was successful, %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSecretAgent</doc>
            <type name="SecretAgent" c:type="NMSecretAgent*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="auto-register"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If TRUE, the agent will attempt to automatically register itself after
it is created (via an idle handler) and to re-register itself if
NetworkManager restarts.  If FALSE, the agent does not automatically
register with NetworkManager, and nm_secret_agent_register() must be
called.  If 'auto-register' is TRUE, calling nm_secret_agent_unregister()
will suppress auto-registration until nm_secret_agent_register() is
called, which re-enables auto-registration.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="capabilities"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A bitfield of %NMSecretAgentCapabilities.</doc>
        <type name="SecretAgentCapabilities"/>
      </property>
      <property name="identifier"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Identifies this agent; only one agent in each user session may use the
same identifier.  Identifier formatting follows the same rules as
D-Bus bus names with the exception that the ':' character is not
allowed.  The valid set of characters is "[A-Z][a-z][0-9]_-." and the
identifier is limited in length to 255 characters with a minimum
of 3 characters.  An example valid identifier is 'org.gnome.nm-applet'
(without quotes).</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="registered" transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the agent is registered with NetworkManager, %FALSE if not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="registration-result" when="first">
        <doc xml:space="preserve">Indicates the result of a registration request; if @error is NULL the
request was successful.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">the error, if any, that occured while registering</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <bitfield name="SecretAgentCapabilities"
              version="0.9.10"
              glib:type-name="NMSecretAgentCapabilities"
              glib:get-type="nm_secret_agent_capabilities_get_type"
              c:type="NMSecretAgentCapabilities">
      <doc xml:space="preserve">#NMSecretAgentCapabilities indicate various capabilities of the agent.</doc>
      <member name="none"
              value="0"
              c:identifier="NM_SECRET_AGENT_CAPABILITY_NONE"
              glib:nick="none">
        <doc xml:space="preserve">the agent supports no special capabilities</doc>
      </member>
      <member name="vpn_hints"
              value="1"
              c:identifier="NM_SECRET_AGENT_CAPABILITY_VPN_HINTS"
              glib:nick="vpn-hints">
        <doc xml:space="preserve">the agent supports sending hints given
by the &lt;literal&gt;get_secrets&lt;/literal&gt; class method to VPN plugin
authentication dialogs.</doc>
      </member>
      <member name="last"
              value="1"
              c:identifier="NM_SECRET_AGENT_CAPABILITY_LAST"
              glib:nick="last">
        <doc xml:space="preserve">bounds checking value; should not be used.</doc>
      </member>
    </bitfield>
    <record name="SecretAgentClass"
            c:type="NMSecretAgentClass"
            glib:is-gtype-struct-for="SecretAgent">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="get_secrets">
        <callback name="get_secrets">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #NMSecretAgent</doc>
              <type name="SecretAgent" c:type="NMSecretAgent*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">the #NMConnection for which we're asked secrets</doc>
              <type name="NetworkManager.Connection" c:type="NMConnection*"/>
            </parameter>
            <parameter name="connection_path" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="setting_name" transfer-ownership="none">
              <doc xml:space="preserve">the name of the secret setting</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="hints" transfer-ownership="none">
              <doc xml:space="preserve">hints to the agent</doc>
              <array c:type="char**">
                <type name="utf8" c:type="char*"/>
              </array>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">flags that modify the behavior of the request</doc>
              <type name="SecretAgentGetSecretsFlags"
                    c:type="NMSecretAgentGetSecretsFlags"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="7">
              <doc xml:space="preserve">a callback, to be invoked when the operation is done</doc>
              <type name="SecretAgentGetSecretsFunc"
                    c:type="NMSecretAgentGetSecretsFunc"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="7">
              <doc xml:space="preserve">caller-specific data to be passed to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="cancel_get_secrets">
        <callback name="cancel_get_secrets">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="SecretAgent" c:type="NMSecretAgent*"/>
            </parameter>
            <parameter name="connection_path" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="setting_name" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="save_secrets">
        <callback name="save_secrets">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #NMSecretAgent</doc>
              <type name="SecretAgent" c:type="NMSecretAgent*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">a #NMConnection</doc>
              <type name="NetworkManager.Connection" c:type="NMConnection*"/>
            </parameter>
            <parameter name="connection_path" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:space="preserve">a callback, to be invoked when the operation is done</doc>
              <type name="SecretAgentSaveSecretsFunc"
                    c:type="NMSecretAgentSaveSecretsFunc"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:space="preserve">caller-specific data to be passed to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="delete_secrets">
        <callback name="delete_secrets">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">a #NMSecretAgent</doc>
              <type name="SecretAgent" c:type="NMSecretAgent*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:space="preserve">a #NMConnection</doc>
              <type name="NetworkManager.Connection" c:type="NMConnection*"/>
            </parameter>
            <parameter name="connection_path" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       scope="async"
                       closure="4">
              <doc xml:space="preserve">a callback, to be invoked when the operation is done</doc>
              <type name="SecretAgentDeleteSecretsFunc"
                    c:type="NMSecretAgentDeleteSecretsFunc"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:space="preserve">caller-specific data to be passed to @callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="registration_result">
        <callback name="registration_result">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="agent" transfer-ownership="none">
              <type name="SecretAgent" c:type="NMSecretAgent*"/>
            </parameter>
            <parameter name="error" transfer-ownership="none">
              <type name="GLib.Error" c:type="GError*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <callback name="SecretAgentDeleteSecretsFunc"
              c:type="NMSecretAgentDeleteSecretsFunc">
      <doc xml:space="preserve">Called as a result of a request by NM to delete secrets.  When the
#NMSecretAgent subclass has finished deleting the secrets, this function
should be called.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="agent" transfer-ownership="none">
          <doc xml:space="preserve">the secret agent object</doc>
          <type name="SecretAgent" c:type="NMSecretAgent*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">the connection for which secrets were to be deleted,
note that this object will be unrefed after the callback has returned, use
g_object_ref()/g_object_unref() if you want to use this object after the callback
has returned</doc>
          <type name="NetworkManager.Connection" c:type="NMConnection*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">if the deleting secrets failed, give a descriptive error here</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:space="preserve">caller-specific data to be passed to the function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="SecretAgentError"
                 glib:type-name="NMSecretAgentError"
                 glib:get-type="nm_secret_agent_error_get_type"
                 c:type="NMSecretAgentError"
                 glib:error-domain="nm-secret-agent-error">
      <doc xml:space="preserve">#NMSecretAgentError values are passed by secret agents back to NetworkManager
when they encounter problems retrieving secrets on behalf of NM.</doc>
      <member name="NotAuthorized"
              value="0"
              c:identifier="NM_SECRET_AGENT_ERROR_NOT_AUTHORIZED"
              glib:nick="NotAuthorized">
        <doc xml:space="preserve">the caller (ie, NetworkManager) is not
 authorized to make this request</doc>
      </member>
      <member name="InvalidConnection"
              value="1"
              c:identifier="NM_SECRET_AGENT_ERROR_INVALID_CONNECTION"
              glib:nick="InvalidConnection">
        <doc xml:space="preserve">the connection for which secrets
 were requested could not be found</doc>
      </member>
      <member name="UserCanceled"
              value="2"
              c:identifier="NM_SECRET_AGENT_ERROR_USER_CANCELED"
              glib:nick="UserCanceled">
        <doc xml:space="preserve">the request was canceled by the user</doc>
      </member>
      <member name="AgentCanceled"
              value="3"
              c:identifier="NM_SECRET_AGENT_ERROR_AGENT_CANCELED"
              glib:nick="AgentCanceled">
        <doc xml:space="preserve">the agent canceled the request
 because it was requested to do so by NetworkManager</doc>
      </member>
      <member name="InternalError"
              value="4"
              c:identifier="NM_SECRET_AGENT_ERROR_INTERNAL_ERROR"
              glib:nick="InternalError">
        <doc xml:space="preserve">some internal error in the agent caused
 the request to fail</doc>
      </member>
      <member name="NoSecrets"
              value="5"
              c:identifier="NM_SECRET_AGENT_ERROR_NO_SECRETS"
              glib:nick="NoSecrets">
        <doc xml:space="preserve">the agent cannot find any secrets for this
 connection</doc>
      </member>
      <function name="quark" c:identifier="nm_secret_agent_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <bitfield name="SecretAgentGetSecretsFlags"
              glib:type-name="NMSecretAgentGetSecretsFlags"
              glib:get-type="nm_secret_agent_get_secrets_flags_get_type"
              c:type="NMSecretAgentGetSecretsFlags">
      <doc xml:space="preserve">#NMSecretAgentGetSecretsFlags values modify the behavior of a GetSecrets request.</doc>
      <member name="none"
              value="0"
              c:identifier="NM_SECRET_AGENT_GET_SECRETS_FLAG_NONE"
              glib:nick="none">
        <doc xml:space="preserve">no special behavior; by default no
user interaction is allowed and requests for secrets are fulfilled from
persistent storage, or if no secrets are available an error is returned.</doc>
      </member>
      <member name="allow_interaction"
              value="1"
              c:identifier="NM_SECRET_AGENT_GET_SECRETS_FLAG_ALLOW_INTERACTION"
              glib:nick="allow-interaction">
        <doc xml:space="preserve">allows the request to
interact with the user, possibly prompting via UI for secrets if any are
required, or if none are found in persistent storage.</doc>
      </member>
      <member name="request_new"
              value="2"
              c:identifier="NM_SECRET_AGENT_GET_SECRETS_FLAG_REQUEST_NEW"
              glib:nick="request-new">
        <doc xml:space="preserve">explicitly prompt for new
secrets from the user.  This flag signals that NetworkManager thinks any
existing secrets are invalid or wrong.  This flag implies that interaction
is allowed.</doc>
      </member>
      <member name="user_requested"
              value="4"
              c:identifier="NM_SECRET_AGENT_GET_SECRETS_FLAG_USER_REQUESTED"
              glib:nick="user-requested">
        <doc xml:space="preserve">set if the request was
initiated by user-requested action via the D-Bus interface, as opposed to
automatically initiated by NetworkManager in response to (for example) scan
results or carrier changes.</doc>
      </member>
    </bitfield>
    <callback name="SecretAgentGetSecretsFunc"
              c:type="NMSecretAgentGetSecretsFunc">
      <doc xml:space="preserve">Called as a result of a request by NM to retrieve secrets.  When the
#NMSecretAgent subclass has finished retrieving secrets and is ready to
return them, or to return an error, this function should be called with
those secrets or the error.

To easily create the hash table to return the Wi-Fi PSK, you could do
something like this:
&lt;example&gt;
 &lt;title&gt;Creating a secrets hash&lt;/title&gt;
 &lt;programlisting&gt;
  NMConnection *secrets;
  NMSettingWirelessSecurity *s_wsec;
  GHashTable *secrets_hash;

  secrets = nm_connection_new ();
  s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
  g_object_set (G_OBJECT (s_wsec),
                NM_SETTING_WIRELESS_SECURITY_PSK, "my really cool PSK",
                NULL);
  nm_connection_add_setting (secrets, NM_SETTING (s_wsec));
  secrets_hash = nm_connection_to_hash (secrets, NM_SETTING_HASH_FLAG_ALL);

  (call the NMSecretAgentGetSecretsFunc with secrets_hash)

  g_object_unref (secrets);
  g_hash_table_unref (secrets_hash);
 &lt;/programlisting&gt;
&lt;/example&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="agent" transfer-ownership="none">
          <doc xml:space="preserve">the secret agent object</doc>
          <type name="SecretAgent" c:type="NMSecretAgent*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">the connection for which secrets were requested,
note that this object will be unrefed after the callback has returned, use
g_object_ref()/g_object_unref() if you want to use this object after the callback
has returned</doc>
          <type name="NetworkManager.Connection" c:type="NMConnection*"/>
        </parameter>
        <parameter name="secrets" transfer-ownership="none">
          <doc xml:space="preserve">the #GHashTable containing
the requested secrets in the same format as an #NMConnection hash (as
created by nm_connection_to_hash() for example).  Each key in @secrets
should be the name of a #NMSetting object (like "802-11-wireless-security")
and each value should be a #GHashTable.  The sub-hashes map string:#GValue
where the string is the setting property name (like "psk") and the value
is the secret</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GLib.HashTable">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </type>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">if the secrets request failed, give a descriptive error here</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="4">
          <doc xml:space="preserve">caller-specific data to be passed to the function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="SecretAgentSaveSecretsFunc"
              c:type="NMSecretAgentSaveSecretsFunc">
      <doc xml:space="preserve">Called as a result of a request by NM to save secrets.  When the
#NMSecretAgent subclass has finished saving the secrets, this function
should be called.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="agent" transfer-ownership="none">
          <doc xml:space="preserve">the secret agent object</doc>
          <type name="SecretAgent" c:type="NMSecretAgent*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">the connection for which secrets were to be saved,
note that this object will be unrefed after the callback has returned, use
g_object_ref()/g_object_unref() if you want to use this object after the callback
has returned</doc>
          <type name="NetworkManager.Connection" c:type="NMConnection*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">if the saving secrets failed, give a descriptive error here</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:space="preserve">caller-specific data to be passed to the function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <glib:boxed glib:name="Ssid"
                c:symbol-prefix="ssid"
                glib:type-name="NMSsid"
                glib:get-type="nm_ssid_get_type">
    </glib:boxed>
    <glib:boxed glib:name="StringArray"
                c:symbol-prefix="string_array"
                glib:type-name="NMStringArray"
                glib:get-type="nm_string_array_get_type">
    </glib:boxed>
    <glib:boxed glib:name="UintArray"
                c:symbol-prefix="uint_array"
                glib:type-name="NMUintArray"
                glib:get-type="nm_uint_array_get_type">
    </glib:boxed>
    <class name="VPNConnection"
           c:symbol-prefix="vpn_connection"
           c:type="NMVPNConnection"
           parent="ActiveConnection"
           glib:type-name="NMVPNConnection"
           glib:get-type="nm_vpn_connection_get_type"
           glib:type-struct="VPNConnectionClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_vpn_connection_new">
        <doc xml:space="preserve">Creates a new #NMVPNConnection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new connection object</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the DBus object path of the new connection</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="vpn_state_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <type name="VPNConnection" c:type="NMVPNConnection*"/>
          </instance-parameter>
          <parameter name="state" transfer-ownership="none">
            <type name="NetworkManager.VPNConnectionState"
                  c:type="NMVPNConnectionState"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <type name="NetworkManager.VPNConnectionStateReason"
                  c:type="NMVPNConnectionStateReason"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_banner" c:identifier="nm_vpn_connection_get_banner">
        <doc xml:space="preserve">Gets the VPN login banner of the active #NMVPNConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the VPN login banner of the VPN connection. This is the internal
string used by the connection, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="vpn" transfer-ownership="none">
            <doc xml:space="preserve">a #NMVPNConnection</doc>
            <type name="VPNConnection" c:type="NMVPNConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vpn_state"
              c:identifier="nm_vpn_connection_get_vpn_state">
        <doc xml:space="preserve">Gets the current #NMVPNConnection state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the VPN state of the active VPN connection.</doc>
          <type name="NetworkManager.VPNConnectionState"
                c:type="NMVPNConnectionState"/>
        </return-value>
        <parameters>
          <instance-parameter name="vpn" transfer-ownership="none">
            <doc xml:space="preserve">a #NMVPNConnection</doc>
            <type name="VPNConnection" c:type="NMVPNConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="banner" transfer-ownership="none">
        <doc xml:space="preserve">The VPN login banner of the active VPN connection.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="vpn-state" transfer-ownership="none">
        <doc xml:space="preserve">The VPN state of the active VPN connection.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="ActiveConnection" c:type="NMActiveConnection"/>
      </field>
      <glib:signal name="vpn-state-changed" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="VPNConnectionClass"
            c:type="NMVPNConnectionClass"
            glib:is-gtype-struct-for="VPNConnection">
      <field name="parent">
        <type name="ActiveConnectionClass" c:type="NMActiveConnectionClass"/>
      </field>
      <field name="vpn_state_changed">
        <callback name="vpn_state_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="connection" transfer-ownership="none">
              <type name="VPNConnection" c:type="NMVPNConnection*"/>
            </parameter>
            <parameter name="state" transfer-ownership="none">
              <type name="NetworkManager.VPNConnectionState"
                    c:type="NMVPNConnectionState"/>
            </parameter>
            <parameter name="reason" transfer-ownership="none">
              <type name="NetworkManager.VPNConnectionStateReason"
                    c:type="NMVPNConnectionStateReason"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <constant name="VPN_CONNECTION_BANNER"
              value="banner"
              c:type="NM_VPN_CONNECTION_BANNER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_CONNECTION_VPN_STATE"
              value="vpn-state"
              c:type="NM_VPN_CONNECTION_VPN_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="WIMAX_NSP_NAME" value="name" c:type="NM_WIMAX_NSP_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="WIMAX_NSP_NETWORK_TYPE"
              value="network-type"
              c:type="NM_WIMAX_NSP_NETWORK_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="WIMAX_NSP_SIGNAL_QUALITY"
              value="signal-quality"
              c:type="NM_WIMAX_NSP_SIGNAL_QUALITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="WimaxNsp"
           c:symbol-prefix="wimax_nsp"
           c:type="NMWimaxNsp"
           parent="Object"
           glib:type-name="NMWimaxNsp"
           glib:get-type="nm_wimax_nsp_get_type"
           glib:type-struct="WimaxNspClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_wimax_nsp_new">
        <doc xml:space="preserve">Creates a new #NMWimaxNsp.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new WiMAX NSP</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the D-Bus object path of the WiMAX NSP</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="connection_valid"
              c:identifier="nm_wimax_nsp_connection_valid">
        <doc xml:space="preserve">Validates a given connection against a given WiMAX NSP to ensure that the
connection may be activated with that NSP.  The connection must match the
@nsp's network name and other attributes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection may be activated with this WiMAX NSP,
%FALSE if it cannot be.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="nsp" transfer-ownership="none">
            <doc xml:space="preserve">an #NMWimaxNsp to validate @connection against</doc>
            <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">an #NMConnection to validate against @nsp</doc>
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="filter_connections"
              c:identifier="nm_wimax_nsp_filter_connections">
        <doc xml:space="preserve">Filters a given list of connections for a given #NMWimaxNsp object and
return connections which may be activated with the access point.  Any
returned connections will match the @nsp's network name and other attributes.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a
list of #NMConnection objects that could be activated with the given @nsp.
The elements of the list are owned by their creator and should not be freed
by the caller, but the returned list itself is owned by the caller and should
be freed with g_slist_free() when it is no longer required.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="NetworkManager.Connection"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="nsp" transfer-ownership="none">
            <doc xml:space="preserve">an #NMWimaxNsp to filter connections for</doc>
            <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
          </instance-parameter>
          <parameter name="connections" transfer-ownership="none">
            <doc xml:space="preserve">a list of
#NMConnection objects to filter</doc>
            <type name="GLib.SList" c:type="const GSList*">
              <type name="NetworkManager.Connection"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="nm_wimax_nsp_get_name">
        <doc xml:space="preserve">Gets the name of the wimax NSP</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="nsp" transfer-ownership="none">
            <doc xml:space="preserve">a #NMWimaxNsp</doc>
            <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_network_type"
              c:identifier="nm_wimax_nsp_get_network_type">
        <doc xml:space="preserve">Gets the network type of the wimax NSP.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the network type</doc>
          <type name="WimaxNspNetworkType" c:type="NMWimaxNspNetworkType"/>
        </return-value>
        <parameters>
          <instance-parameter name="nsp" transfer-ownership="none">
            <doc xml:space="preserve">a #NMWimaxNsp</doc>
            <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_signal_quality"
              c:identifier="nm_wimax_nsp_get_signal_quality">
        <doc xml:space="preserve">Gets the WPA signal quality of the wimax NSP.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the signal quality</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="nsp" transfer-ownership="none">
            <doc xml:space="preserve">a #NMWimaxNsp</doc>
            <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="name" transfer-ownership="none">
        <doc xml:space="preserve">The name of the WiMAX NSP.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="network-type" transfer-ownership="none">
        <doc xml:space="preserve">The network type of the WiMAX NSP.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="signal-quality" transfer-ownership="none">
        <doc xml:space="preserve">The signal quality of the WiMAX NSP.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Object" c:type="NMObject"/>
      </field>
    </class>
    <record name="WimaxNspClass"
            c:type="NMWimaxNspClass"
            glib:is-gtype-struct-for="WimaxNsp">
      <field name="parent">
        <type name="ObjectClass" c:type="NMObjectClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="WimaxNspNetworkType"
                 glib:type-name="NMWimaxNspNetworkType"
                 glib:get-type="nm_wimax_nsp_network_type_get_type"
                 c:type="NMWimaxNspNetworkType">
      <doc xml:space="preserve">WiMAX network type.</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_WIMAX_NSP_NETWORK_TYPE_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">unknown network type</doc>
      </member>
      <member name="home"
              value="1"
              c:identifier="NM_WIMAX_NSP_NETWORK_TYPE_HOME"
              glib:nick="home">
        <doc xml:space="preserve">home network</doc>
      </member>
      <member name="partner"
              value="2"
              c:identifier="NM_WIMAX_NSP_NETWORK_TYPE_PARTNER"
              glib:nick="partner">
        <doc xml:space="preserve">partner network</doc>
      </member>
      <member name="roaming_partner"
              value="3"
              c:identifier="NM_WIMAX_NSP_NETWORK_TYPE_ROAMING_PARTNER"
              glib:nick="roaming-partner">
        <doc xml:space="preserve">roaming partner network</doc>
      </member>
    </enumeration>
    <function name="client_error_quark"
              c:identifier="nm_client_error_quark"
              moved-to="ClientError.quark"
              version="0.9.10">
      <doc xml:space="preserve">Registers an error quark for #NMClient if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMClient errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="device_adsl_error_quark"
              c:identifier="nm_device_adsl_error_quark"
              moved-to="DeviceAdslError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMDeviceAdsl if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMDeviceAdsl errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="device_bond_error_quark"
              c:identifier="nm_device_bond_error_quark"
              moved-to="DeviceBondError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMDeviceBond if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMDeviceBond errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="device_bridge_error_quark"
              c:identifier="nm_device_bridge_error_quark"
              moved-to="DeviceBridgeError.quark"
              version="0.9.8">
      <doc xml:space="preserve">Registers an error quark for #NMDeviceBridge if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMDeviceBridge errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="device_bt_error_quark"
              c:identifier="nm_device_bt_error_quark"
              moved-to="DeviceBtError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMDeviceBt if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMDeviceBt errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="device_error_quark"
              c:identifier="nm_device_error_quark"
              moved-to="DeviceError.quark"
              version="0.9.10">
      <doc xml:space="preserve">Registers an error quark for #NMDevice if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMDevice errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="device_ethernet_error_quark"
              c:identifier="nm_device_ethernet_error_quark"
              moved-to="DeviceEthernetError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMDeviceEthernet if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMDeviceEthernet errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="device_generic_error_quark"
              c:identifier="nm_device_generic_error_quark"
              moved-to="DeviceGenericError.quark"
              version="0.9.10">
      <doc xml:space="preserve">Registers an error quark for #NMDeviceGeneric if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMDeviceGeneric errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="device_infiniband_error_quark"
              c:identifier="nm_device_infiniband_error_quark"
              moved-to="DeviceInfinibandError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMDeviceInfiniband if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMDeviceInfiniband errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="device_modem_error_quark"
              c:identifier="nm_device_modem_error_quark"
              moved-to="DeviceModemError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMDeviceModem if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMDeviceModem errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="device_olpc_mesh_error_quark"
              c:identifier="nm_device_olpc_mesh_error_quark"
              moved-to="DeviceOlpcMeshError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMDeviceOlpcMesh if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMDeviceOlpcMesh errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="device_team_error_quark"
              c:identifier="nm_device_team_error_quark"
              moved-to="DeviceTeamError.quark"
              version="0.9.10">
      <doc xml:space="preserve">Registers an error quark for #NMDeviceTeam if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMDeviceTeam errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="device_vlan_error_quark"
              c:identifier="nm_device_vlan_error_quark"
              moved-to="DeviceVlanError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMDeviceVlan if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMDeviceVlan errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="device_wifi_error_quark"
              c:identifier="nm_device_wifi_error_quark"
              moved-to="DeviceWifiError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMDeviceWifi if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMDeviceWifi errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="device_wimax_error_quark"
              c:identifier="nm_device_wimax_error_quark"
              moved-to="DeviceWimaxError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMDeviceWimax if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMDeviceWimax errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="object_error_quark"
              c:identifier="nm_object_error_quark"
              moved-to="ObjectError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMObject if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMObject errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="remote_connection_error_quark"
              c:identifier="nm_remote_connection_error_quark"
              moved-to="RemoteConnectionError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMRemoteConnection if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMRemoteConnection errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="remote_settings_error_quark"
              c:identifier="nm_remote_settings_error_quark"
              moved-to="RemoteSettingsError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMRemoteSettings if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMRemoteSettings errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="secret_agent_error_quark"
              c:identifier="nm_secret_agent_error_quark"
              moved-to="SecretAgentError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
  </namespace>
</repository>
